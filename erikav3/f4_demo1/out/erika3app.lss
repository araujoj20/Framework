
erika3app.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000232c  080001c0  080001c0  000101c0  2**6
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000001a8  080024ec  080024ec  000124ec  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  08002694  08002694  00012694  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000008  0800269c  0800269c  0001269c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  080026a4  080026a4  000126a4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000490  20000000  080026a8  00020000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  7 .ccmram       00000000  10000000  10000000  00020490  2**0
                  CONTENTS
  8 .bss          000004bc  20000490  20000490  00020490  2**3
                  ALLOC
  9 ._user_heap_stack 00000600  2000094c  2000094c  00020490  2**0
                  ALLOC
 10 .ARM.attributes 0000002a  00000000  00000000  00020490  2**0
                  CONTENTS, READONLY
 11 .debug_line   0000d03f  00000000  00000000  000204ba  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   00010db4  00000000  00000000  0002d4f9  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 000034b1  00000000  00000000  0003e2ad  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 00000a10  00000000  00000000  00041760  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    000fd0c4  00000000  00000000  00042170  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000a48  00000000  00000000  0013f238  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    00005399  00000000  00000000  0013fc80  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_macro  00039567  00000000  00000000  00145019  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .comment      0000007f  00000000  00000000  0017e580  2**0
                  CONTENTS, READONLY
 20 .debug_frame  000018fc  00000000  00000000  0017e600  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001c0 <__do_global_dtors_aux>:
 80001c0:	b510      	push	{r4, lr}
 80001c2:	4c05      	ldr	r4, [pc, #20]	; (80001d8 <__do_global_dtors_aux+0x18>)
 80001c4:	7823      	ldrb	r3, [r4, #0]
 80001c6:	b933      	cbnz	r3, 80001d6 <__do_global_dtors_aux+0x16>
 80001c8:	4b04      	ldr	r3, [pc, #16]	; (80001dc <__do_global_dtors_aux+0x1c>)
 80001ca:	b113      	cbz	r3, 80001d2 <__do_global_dtors_aux+0x12>
 80001cc:	4804      	ldr	r0, [pc, #16]	; (80001e0 <__do_global_dtors_aux+0x20>)
 80001ce:	f3af 8000 	nop.w
 80001d2:	2301      	movs	r3, #1
 80001d4:	7023      	strb	r3, [r4, #0]
 80001d6:	bd10      	pop	{r4, pc}
 80001d8:	20000490 	.word	0x20000490
 80001dc:	00000000 	.word	0x00000000
 80001e0:	080024d4 	.word	0x080024d4

080001e4 <frame_dummy>:
 80001e4:	b508      	push	{r3, lr}
 80001e6:	4b03      	ldr	r3, [pc, #12]	; (80001f4 <frame_dummy+0x10>)
 80001e8:	b11b      	cbz	r3, 80001f2 <frame_dummy+0xe>
 80001ea:	4903      	ldr	r1, [pc, #12]	; (80001f8 <frame_dummy+0x14>)
 80001ec:	4803      	ldr	r0, [pc, #12]	; (80001fc <frame_dummy+0x18>)
 80001ee:	f3af 8000 	nop.w
 80001f2:	bd08      	pop	{r3, pc}
 80001f4:	00000000 	.word	0x00000000
 80001f8:	20000494 	.word	0x20000494
 80001fc:	080024d4 	.word	0x080024d4

08000200 <strlen>:
 8000200:	f890 f000 	pld	[r0]
 8000204:	e96d 4502 	strd	r4, r5, [sp, #-8]!
 8000208:	f020 0107 	bic.w	r1, r0, #7
 800020c:	f06f 0c00 	mvn.w	ip, #0
 8000210:	f010 0407 	ands.w	r4, r0, #7
 8000214:	f891 f020 	pld	[r1, #32]
 8000218:	f040 8049 	bne.w	80002ae <strlen+0xae>
 800021c:	f04f 0400 	mov.w	r4, #0
 8000220:	f06f 0007 	mvn.w	r0, #7
 8000224:	e9d1 2300 	ldrd	r2, r3, [r1]
 8000228:	f891 f040 	pld	[r1, #64]	; 0x40
 800022c:	f100 0008 	add.w	r0, r0, #8
 8000230:	fa82 f24c 	uadd8	r2, r2, ip
 8000234:	faa4 f28c 	sel	r2, r4, ip
 8000238:	fa83 f34c 	uadd8	r3, r3, ip
 800023c:	faa2 f38c 	sel	r3, r2, ip
 8000240:	bb4b      	cbnz	r3, 8000296 <strlen+0x96>
 8000242:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
 8000246:	fa82 f24c 	uadd8	r2, r2, ip
 800024a:	f100 0008 	add.w	r0, r0, #8
 800024e:	faa4 f28c 	sel	r2, r4, ip
 8000252:	fa83 f34c 	uadd8	r3, r3, ip
 8000256:	faa2 f38c 	sel	r3, r2, ip
 800025a:	b9e3      	cbnz	r3, 8000296 <strlen+0x96>
 800025c:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
 8000260:	fa82 f24c 	uadd8	r2, r2, ip
 8000264:	f100 0008 	add.w	r0, r0, #8
 8000268:	faa4 f28c 	sel	r2, r4, ip
 800026c:	fa83 f34c 	uadd8	r3, r3, ip
 8000270:	faa2 f38c 	sel	r3, r2, ip
 8000274:	b97b      	cbnz	r3, 8000296 <strlen+0x96>
 8000276:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
 800027a:	f101 0120 	add.w	r1, r1, #32
 800027e:	fa82 f24c 	uadd8	r2, r2, ip
 8000282:	f100 0008 	add.w	r0, r0, #8
 8000286:	faa4 f28c 	sel	r2, r4, ip
 800028a:	fa83 f34c 	uadd8	r3, r3, ip
 800028e:	faa2 f38c 	sel	r3, r2, ip
 8000292:	2b00      	cmp	r3, #0
 8000294:	d0c6      	beq.n	8000224 <strlen+0x24>
 8000296:	2a00      	cmp	r2, #0
 8000298:	bf04      	itt	eq
 800029a:	3004      	addeq	r0, #4
 800029c:	461a      	moveq	r2, r3
 800029e:	ba12      	rev	r2, r2
 80002a0:	fab2 f282 	clz	r2, r2
 80002a4:	e8fd 4502 	ldrd	r4, r5, [sp], #8
 80002a8:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
 80002ac:	4770      	bx	lr
 80002ae:	e9d1 2300 	ldrd	r2, r3, [r1]
 80002b2:	f004 0503 	and.w	r5, r4, #3
 80002b6:	f1c4 0000 	rsb	r0, r4, #0
 80002ba:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 80002be:	f014 0f04 	tst.w	r4, #4
 80002c2:	f891 f040 	pld	[r1, #64]	; 0x40
 80002c6:	fa0c f505 	lsl.w	r5, ip, r5
 80002ca:	ea62 0205 	orn	r2, r2, r5
 80002ce:	bf1c      	itt	ne
 80002d0:	ea63 0305 	ornne	r3, r3, r5
 80002d4:	4662      	movne	r2, ip
 80002d6:	f04f 0400 	mov.w	r4, #0
 80002da:	e7a9      	b.n	8000230 <strlen+0x30>

080002dc <__aeabi_uldivmod>:
 80002dc:	b953      	cbnz	r3, 80002f4 <__aeabi_uldivmod+0x18>
 80002de:	b94a      	cbnz	r2, 80002f4 <__aeabi_uldivmod+0x18>
 80002e0:	2900      	cmp	r1, #0
 80002e2:	bf08      	it	eq
 80002e4:	2800      	cmpeq	r0, #0
 80002e6:	bf1c      	itt	ne
 80002e8:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 80002ec:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 80002f0:	f000 b972 	b.w	80005d8 <__aeabi_idiv0>
 80002f4:	f1ad 0c08 	sub.w	ip, sp, #8
 80002f8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80002fc:	f000 f806 	bl	800030c <__udivmoddi4>
 8000300:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000304:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000308:	b004      	add	sp, #16
 800030a:	4770      	bx	lr

0800030c <__udivmoddi4>:
 800030c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000310:	9e08      	ldr	r6, [sp, #32]
 8000312:	4604      	mov	r4, r0
 8000314:	4688      	mov	r8, r1
 8000316:	2b00      	cmp	r3, #0
 8000318:	d14b      	bne.n	80003b2 <__udivmoddi4+0xa6>
 800031a:	428a      	cmp	r2, r1
 800031c:	4615      	mov	r5, r2
 800031e:	d967      	bls.n	80003f0 <__udivmoddi4+0xe4>
 8000320:	fab2 f282 	clz	r2, r2
 8000324:	b14a      	cbz	r2, 800033a <__udivmoddi4+0x2e>
 8000326:	f1c2 0720 	rsb	r7, r2, #32
 800032a:	fa01 f302 	lsl.w	r3, r1, r2
 800032e:	fa20 f707 	lsr.w	r7, r0, r7
 8000332:	4095      	lsls	r5, r2
 8000334:	ea47 0803 	orr.w	r8, r7, r3
 8000338:	4094      	lsls	r4, r2
 800033a:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 800033e:	0c23      	lsrs	r3, r4, #16
 8000340:	fbb8 f7fe 	udiv	r7, r8, lr
 8000344:	fa1f fc85 	uxth.w	ip, r5
 8000348:	fb0e 8817 	mls	r8, lr, r7, r8
 800034c:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8000350:	fb07 f10c 	mul.w	r1, r7, ip
 8000354:	4299      	cmp	r1, r3
 8000356:	d909      	bls.n	800036c <__udivmoddi4+0x60>
 8000358:	18eb      	adds	r3, r5, r3
 800035a:	f107 30ff 	add.w	r0, r7, #4294967295	; 0xffffffff
 800035e:	f080 811b 	bcs.w	8000598 <__udivmoddi4+0x28c>
 8000362:	4299      	cmp	r1, r3
 8000364:	f240 8118 	bls.w	8000598 <__udivmoddi4+0x28c>
 8000368:	3f02      	subs	r7, #2
 800036a:	442b      	add	r3, r5
 800036c:	1a5b      	subs	r3, r3, r1
 800036e:	b2a4      	uxth	r4, r4
 8000370:	fbb3 f0fe 	udiv	r0, r3, lr
 8000374:	fb0e 3310 	mls	r3, lr, r0, r3
 8000378:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 800037c:	fb00 fc0c 	mul.w	ip, r0, ip
 8000380:	45a4      	cmp	ip, r4
 8000382:	d909      	bls.n	8000398 <__udivmoddi4+0x8c>
 8000384:	192c      	adds	r4, r5, r4
 8000386:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 800038a:	f080 8107 	bcs.w	800059c <__udivmoddi4+0x290>
 800038e:	45a4      	cmp	ip, r4
 8000390:	f240 8104 	bls.w	800059c <__udivmoddi4+0x290>
 8000394:	3802      	subs	r0, #2
 8000396:	442c      	add	r4, r5
 8000398:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 800039c:	eba4 040c 	sub.w	r4, r4, ip
 80003a0:	2700      	movs	r7, #0
 80003a2:	b11e      	cbz	r6, 80003ac <__udivmoddi4+0xa0>
 80003a4:	40d4      	lsrs	r4, r2
 80003a6:	2300      	movs	r3, #0
 80003a8:	e9c6 4300 	strd	r4, r3, [r6]
 80003ac:	4639      	mov	r1, r7
 80003ae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80003b2:	428b      	cmp	r3, r1
 80003b4:	d909      	bls.n	80003ca <__udivmoddi4+0xbe>
 80003b6:	2e00      	cmp	r6, #0
 80003b8:	f000 80eb 	beq.w	8000592 <__udivmoddi4+0x286>
 80003bc:	2700      	movs	r7, #0
 80003be:	e9c6 0100 	strd	r0, r1, [r6]
 80003c2:	4638      	mov	r0, r7
 80003c4:	4639      	mov	r1, r7
 80003c6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80003ca:	fab3 f783 	clz	r7, r3
 80003ce:	2f00      	cmp	r7, #0
 80003d0:	d147      	bne.n	8000462 <__udivmoddi4+0x156>
 80003d2:	428b      	cmp	r3, r1
 80003d4:	d302      	bcc.n	80003dc <__udivmoddi4+0xd0>
 80003d6:	4282      	cmp	r2, r0
 80003d8:	f200 80fa 	bhi.w	80005d0 <__udivmoddi4+0x2c4>
 80003dc:	1a84      	subs	r4, r0, r2
 80003de:	eb61 0303 	sbc.w	r3, r1, r3
 80003e2:	2001      	movs	r0, #1
 80003e4:	4698      	mov	r8, r3
 80003e6:	2e00      	cmp	r6, #0
 80003e8:	d0e0      	beq.n	80003ac <__udivmoddi4+0xa0>
 80003ea:	e9c6 4800 	strd	r4, r8, [r6]
 80003ee:	e7dd      	b.n	80003ac <__udivmoddi4+0xa0>
 80003f0:	b902      	cbnz	r2, 80003f4 <__udivmoddi4+0xe8>
 80003f2:	deff      	udf	#255	; 0xff
 80003f4:	fab2 f282 	clz	r2, r2
 80003f8:	2a00      	cmp	r2, #0
 80003fa:	f040 808f 	bne.w	800051c <__udivmoddi4+0x210>
 80003fe:	1b49      	subs	r1, r1, r5
 8000400:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000404:	fa1f f885 	uxth.w	r8, r5
 8000408:	2701      	movs	r7, #1
 800040a:	fbb1 fcfe 	udiv	ip, r1, lr
 800040e:	0c23      	lsrs	r3, r4, #16
 8000410:	fb0e 111c 	mls	r1, lr, ip, r1
 8000414:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000418:	fb08 f10c 	mul.w	r1, r8, ip
 800041c:	4299      	cmp	r1, r3
 800041e:	d907      	bls.n	8000430 <__udivmoddi4+0x124>
 8000420:	18eb      	adds	r3, r5, r3
 8000422:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
 8000426:	d202      	bcs.n	800042e <__udivmoddi4+0x122>
 8000428:	4299      	cmp	r1, r3
 800042a:	f200 80cd 	bhi.w	80005c8 <__udivmoddi4+0x2bc>
 800042e:	4684      	mov	ip, r0
 8000430:	1a59      	subs	r1, r3, r1
 8000432:	b2a3      	uxth	r3, r4
 8000434:	fbb1 f0fe 	udiv	r0, r1, lr
 8000438:	fb0e 1410 	mls	r4, lr, r0, r1
 800043c:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
 8000440:	fb08 f800 	mul.w	r8, r8, r0
 8000444:	45a0      	cmp	r8, r4
 8000446:	d907      	bls.n	8000458 <__udivmoddi4+0x14c>
 8000448:	192c      	adds	r4, r5, r4
 800044a:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 800044e:	d202      	bcs.n	8000456 <__udivmoddi4+0x14a>
 8000450:	45a0      	cmp	r8, r4
 8000452:	f200 80b6 	bhi.w	80005c2 <__udivmoddi4+0x2b6>
 8000456:	4618      	mov	r0, r3
 8000458:	eba4 0408 	sub.w	r4, r4, r8
 800045c:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 8000460:	e79f      	b.n	80003a2 <__udivmoddi4+0x96>
 8000462:	f1c7 0c20 	rsb	ip, r7, #32
 8000466:	40bb      	lsls	r3, r7
 8000468:	fa22 fe0c 	lsr.w	lr, r2, ip
 800046c:	ea4e 0e03 	orr.w	lr, lr, r3
 8000470:	fa01 f407 	lsl.w	r4, r1, r7
 8000474:	fa20 f50c 	lsr.w	r5, r0, ip
 8000478:	fa21 f30c 	lsr.w	r3, r1, ip
 800047c:	ea4f 481e 	mov.w	r8, lr, lsr #16
 8000480:	4325      	orrs	r5, r4
 8000482:	fbb3 f9f8 	udiv	r9, r3, r8
 8000486:	0c2c      	lsrs	r4, r5, #16
 8000488:	fb08 3319 	mls	r3, r8, r9, r3
 800048c:	fa1f fa8e 	uxth.w	sl, lr
 8000490:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
 8000494:	fb09 f40a 	mul.w	r4, r9, sl
 8000498:	429c      	cmp	r4, r3
 800049a:	fa02 f207 	lsl.w	r2, r2, r7
 800049e:	fa00 f107 	lsl.w	r1, r0, r7
 80004a2:	d90b      	bls.n	80004bc <__udivmoddi4+0x1b0>
 80004a4:	eb1e 0303 	adds.w	r3, lr, r3
 80004a8:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
 80004ac:	f080 8087 	bcs.w	80005be <__udivmoddi4+0x2b2>
 80004b0:	429c      	cmp	r4, r3
 80004b2:	f240 8084 	bls.w	80005be <__udivmoddi4+0x2b2>
 80004b6:	f1a9 0902 	sub.w	r9, r9, #2
 80004ba:	4473      	add	r3, lr
 80004bc:	1b1b      	subs	r3, r3, r4
 80004be:	b2ad      	uxth	r5, r5
 80004c0:	fbb3 f0f8 	udiv	r0, r3, r8
 80004c4:	fb08 3310 	mls	r3, r8, r0, r3
 80004c8:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
 80004cc:	fb00 fa0a 	mul.w	sl, r0, sl
 80004d0:	45a2      	cmp	sl, r4
 80004d2:	d908      	bls.n	80004e6 <__udivmoddi4+0x1da>
 80004d4:	eb1e 0404 	adds.w	r4, lr, r4
 80004d8:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 80004dc:	d26b      	bcs.n	80005b6 <__udivmoddi4+0x2aa>
 80004de:	45a2      	cmp	sl, r4
 80004e0:	d969      	bls.n	80005b6 <__udivmoddi4+0x2aa>
 80004e2:	3802      	subs	r0, #2
 80004e4:	4474      	add	r4, lr
 80004e6:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 80004ea:	fba0 8902 	umull	r8, r9, r0, r2
 80004ee:	eba4 040a 	sub.w	r4, r4, sl
 80004f2:	454c      	cmp	r4, r9
 80004f4:	46c2      	mov	sl, r8
 80004f6:	464b      	mov	r3, r9
 80004f8:	d354      	bcc.n	80005a4 <__udivmoddi4+0x298>
 80004fa:	d051      	beq.n	80005a0 <__udivmoddi4+0x294>
 80004fc:	2e00      	cmp	r6, #0
 80004fe:	d069      	beq.n	80005d4 <__udivmoddi4+0x2c8>
 8000500:	ebb1 050a 	subs.w	r5, r1, sl
 8000504:	eb64 0403 	sbc.w	r4, r4, r3
 8000508:	fa04 fc0c 	lsl.w	ip, r4, ip
 800050c:	40fd      	lsrs	r5, r7
 800050e:	40fc      	lsrs	r4, r7
 8000510:	ea4c 0505 	orr.w	r5, ip, r5
 8000514:	e9c6 5400 	strd	r5, r4, [r6]
 8000518:	2700      	movs	r7, #0
 800051a:	e747      	b.n	80003ac <__udivmoddi4+0xa0>
 800051c:	f1c2 0320 	rsb	r3, r2, #32
 8000520:	fa20 f703 	lsr.w	r7, r0, r3
 8000524:	4095      	lsls	r5, r2
 8000526:	fa01 f002 	lsl.w	r0, r1, r2
 800052a:	fa21 f303 	lsr.w	r3, r1, r3
 800052e:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000532:	4338      	orrs	r0, r7
 8000534:	0c01      	lsrs	r1, r0, #16
 8000536:	fbb3 f7fe 	udiv	r7, r3, lr
 800053a:	fa1f f885 	uxth.w	r8, r5
 800053e:	fb0e 3317 	mls	r3, lr, r7, r3
 8000542:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8000546:	fb07 f308 	mul.w	r3, r7, r8
 800054a:	428b      	cmp	r3, r1
 800054c:	fa04 f402 	lsl.w	r4, r4, r2
 8000550:	d907      	bls.n	8000562 <__udivmoddi4+0x256>
 8000552:	1869      	adds	r1, r5, r1
 8000554:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
 8000558:	d22f      	bcs.n	80005ba <__udivmoddi4+0x2ae>
 800055a:	428b      	cmp	r3, r1
 800055c:	d92d      	bls.n	80005ba <__udivmoddi4+0x2ae>
 800055e:	3f02      	subs	r7, #2
 8000560:	4429      	add	r1, r5
 8000562:	1acb      	subs	r3, r1, r3
 8000564:	b281      	uxth	r1, r0
 8000566:	fbb3 f0fe 	udiv	r0, r3, lr
 800056a:	fb0e 3310 	mls	r3, lr, r0, r3
 800056e:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8000572:	fb00 f308 	mul.w	r3, r0, r8
 8000576:	428b      	cmp	r3, r1
 8000578:	d907      	bls.n	800058a <__udivmoddi4+0x27e>
 800057a:	1869      	adds	r1, r5, r1
 800057c:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
 8000580:	d217      	bcs.n	80005b2 <__udivmoddi4+0x2a6>
 8000582:	428b      	cmp	r3, r1
 8000584:	d915      	bls.n	80005b2 <__udivmoddi4+0x2a6>
 8000586:	3802      	subs	r0, #2
 8000588:	4429      	add	r1, r5
 800058a:	1ac9      	subs	r1, r1, r3
 800058c:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
 8000590:	e73b      	b.n	800040a <__udivmoddi4+0xfe>
 8000592:	4637      	mov	r7, r6
 8000594:	4630      	mov	r0, r6
 8000596:	e709      	b.n	80003ac <__udivmoddi4+0xa0>
 8000598:	4607      	mov	r7, r0
 800059a:	e6e7      	b.n	800036c <__udivmoddi4+0x60>
 800059c:	4618      	mov	r0, r3
 800059e:	e6fb      	b.n	8000398 <__udivmoddi4+0x8c>
 80005a0:	4541      	cmp	r1, r8
 80005a2:	d2ab      	bcs.n	80004fc <__udivmoddi4+0x1f0>
 80005a4:	ebb8 0a02 	subs.w	sl, r8, r2
 80005a8:	eb69 020e 	sbc.w	r2, r9, lr
 80005ac:	3801      	subs	r0, #1
 80005ae:	4613      	mov	r3, r2
 80005b0:	e7a4      	b.n	80004fc <__udivmoddi4+0x1f0>
 80005b2:	4660      	mov	r0, ip
 80005b4:	e7e9      	b.n	800058a <__udivmoddi4+0x27e>
 80005b6:	4618      	mov	r0, r3
 80005b8:	e795      	b.n	80004e6 <__udivmoddi4+0x1da>
 80005ba:	4667      	mov	r7, ip
 80005bc:	e7d1      	b.n	8000562 <__udivmoddi4+0x256>
 80005be:	4681      	mov	r9, r0
 80005c0:	e77c      	b.n	80004bc <__udivmoddi4+0x1b0>
 80005c2:	3802      	subs	r0, #2
 80005c4:	442c      	add	r4, r5
 80005c6:	e747      	b.n	8000458 <__udivmoddi4+0x14c>
 80005c8:	f1ac 0c02 	sub.w	ip, ip, #2
 80005cc:	442b      	add	r3, r5
 80005ce:	e72f      	b.n	8000430 <__udivmoddi4+0x124>
 80005d0:	4638      	mov	r0, r7
 80005d2:	e708      	b.n	80003e6 <__udivmoddi4+0xda>
 80005d4:	4637      	mov	r7, r6
 80005d6:	e6e9      	b.n	80003ac <__udivmoddi4+0xa0>

080005d8 <__aeabi_idiv0>:
 80005d8:	4770      	bx	lr
 80005da:	bf00      	nop

080005dc <osEE_hal_save_ctx_and_restore_ctx>:
	/*
	 * R0 parameter:	OsEE_TDB * p_to_tdb
	 * R1 parameter:	OsEE_SCB * p_to_scb
	 * R2 parameter: 	OsEE_SCB * p_from_scb
	 */
	osEE_hal_save_vcontext_m R2
 80005dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80005e0:	f3ef 8403 	mrs	r4, PSR
 80005e4:	b410      	push	{r4}
 80005e6:	4614      	mov	r4, r2
 80005e8:	6825      	ldr	r5, [r4, #0]
 80005ea:	b460      	push	{r5, r6}
 80005ec:	f3ef 8508 	mrs	r5, MSP
 80005f0:	6025      	str	r5, [r4, #0]
	B	osEE_hal_restore_ctx
 80005f2:	f000 b801 	b.w	80005f8 <osEE_hal_restore_ctx>
 80005f6:	bf00      	nop

080005f8 <osEE_hal_restore_ctx>:
osEE_hal_restore_ctx:
	/*
	 * R0 parameter:	OsEE_TDB * p_to_tdb
	 * R1 parameter:	OsEE_SCB * p_to_scb
	 */
	osEE_hal_restore_vcontext_m R1
 80005f8:	460c      	mov	r4, r1
 80005fa:	6825      	ldr	r5, [r4, #0]
 80005fc:	f385 8808 	msr	MSP, r5
 8000600:	bc60      	pop	{r5, r6}
 8000602:	6025      	str	r5, [r4, #0]
 8000604:	bc10      	pop	{r4}
 8000606:	f04f 7580 	mov.w	r5, #16777216	; 0x1000000
 800060a:	432c      	orrs	r4, r5
 800060c:	f384 8803 	msr	PSR, r4
 8000610:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	B	osEE_scheduler_task_wrapper_restore
 8000614:	f001 bd8e 	b.w	8002134 <osEE_scheduler_task_wrapper_restore>

08000618 <osEE_hal_ready2stacked>:
	MRS	R4, CONTROL
	LDR	R5, =CONTROL_FPCA_NEG
	ANDS	R4, R4, R5
	MSR	CONTROL, R4
#endif	/* defined(OS_EE_ARCH_CORTEX_M_M7F_FPU) */
	LDR	R2, [R1]
 8000618:	680a      	ldr	r2, [r1, #0]
	/* sp = R2 */
	MSR	MSP, R2
 800061a:	f382 8808 	msr	MSP, r2
	B	osEE_scheduler_task_wrapper_run
 800061e:	f001 bd8d 	b.w	800213c <osEE_scheduler_task_wrapper_run>
 8000622:	bf00      	nop

08000624 <osEE_hal_save_ctx_and_ready2stacked>:
	/*
	 * R0 parameter:	OsEE_TDB * p_to_tdb
	 * R1 parameter:	OsEE_SCB * p_to_scb
	 * R2 parameter:	OsEE_SCB * p_from_scb
	*/
	osEE_hal_save_vcontext_m R2
 8000624:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000628:	f3ef 8403 	mrs	r4, PSR
 800062c:	b410      	push	{r4}
 800062e:	4614      	mov	r4, r2
 8000630:	6825      	ldr	r5, [r4, #0]
 8000632:	b460      	push	{r5, r6}
 8000634:	f3ef 8508 	mrs	r5, MSP
 8000638:	6025      	str	r5, [r4, #0]
	B	osEE_hal_ready2stacked
 800063a:	f7ff bfed 	b.w	8000618 <osEE_hal_ready2stacked>
 800063e:	bf00      	nop

08000640 <osEE_hal_terminate_ctx>:
	MRS	R4, CONTROL
	LDR	R5, =CONTROL_FPCA_NEG
	ANDS	R4, R4, R5
	MSR	CONTROL, R4
#endif	/* defined(OS_EE_ARCH_CORTEX_M_M7F_FPU) */
	LDR	R2, [R0]
 8000640:	6802      	ldr	r2, [r0, #0]
	/* Unwind SP */
	MSR	MSP, R2
 8000642:	f382 8808 	msr	MSP, r2
	/*  Jump to kern_callback (that schedule) */
	BX	R1
 8000646:	4708      	bx	r1

08000648 <osEE_cortex_m_restore_ctx>:
osEE_cortex_m_restore_ctx:
	/*
	 * R0 parameter:	OsEE_TDB * p_to_tdb
	 * R1 parameter:	OsEE_SCB * p_to_scb
	 */
	osEE_hal_restore_vcontext_m R1
 8000648:	460c      	mov	r4, r1
 800064a:	6825      	ldr	r5, [r4, #0]
 800064c:	f385 8808 	msr	MSP, r5
 8000650:	bc60      	pop	{r5, r6}
 8000652:	6025      	str	r5, [r4, #0]
 8000654:	bc10      	pop	{r4}
 8000656:	f04f 7580 	mov.w	r5, #16777216	; 0x1000000
 800065a:	432c      	orrs	r4, r5
 800065c:	f384 8803 	msr	PSR, r4
 8000660:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	BX	LR
 8000664:	4770      	bx	lr
 8000666:	bf00      	nop

08000668 <osEE_set_switch_context_pri>:
	.global	osEE_set_switch_context_pri
	.type	osEE_set_switch_context_pri, #function
osEE_set_switch_context_pri:

	/* Set PendSV priority to the minumum one */
	LDR	R0, =NVIC_SHPR3
 8000668:	4815      	ldr	r0, [pc, #84]	; (80006c0 <NMI_Handler+0x8>)
	LDR	R1, =NVIC_PENDSV_PRI
 800066a:	f44f 017f 	mov.w	r1, #16711680	; 0xff0000
	LDR	R2, [R0]
 800066e:	6802      	ldr	r2, [r0, #0]
	ORRS	R2, R2, R1
 8000670:	430a      	orrs	r2, r1
	STR	R2, [R0]
 8000672:	6002      	str	r2, [r0, #0]

	/* SVCall priority to the maximum one */
	LDR	R0, =NVIC_SHPR2
 8000674:	4813      	ldr	r0, [pc, #76]	; (80006c4 <NMI_Handler+0xc>)
	LDR	R1, =NVIC_SVCALL_PRI
 8000676:	f06f 417f 	mvn.w	r1, #4278190080	; 0xff000000
	LDR	R2, [R0]
 800067a:	6802      	ldr	r2, [r0, #0]
	ANDS	R2, R2, R1
 800067c:	400a      	ands	r2, r1
	STR	R2, [R0]
 800067e:	6002      	str	r2, [r0, #0]

	BX	LR
 8000680:	4770      	bx	lr
 8000682:	bf00      	nop

08000684 <osEE_cortex_m_trigger_pend_sv>:
osEE_cortex_m_trigger_pend_sv:

	/* 
	 * Trigger the PendSV exception (causes context switch)
	 */
	LDR	R0, =NVIC_INT_CTRL
 8000684:	4810      	ldr	r0, [pc, #64]	; (80006c8 <NMI_Handler+0x10>)
	LDR	R1, =NVIC_PENDSVSET
 8000686:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
	STR	R1, [R0]
 800068a:	6001      	str	r1, [r0, #0]

	BX	LR
 800068c:	4770      	bx	lr
 800068e:	bf00      	nop

08000690 <PendSV_Handler>:
	.global	PendSV_Handler
	.type	PendSV_Handler, %function
PendSV_Handler:

	/* Disable interrupts (set PRIMASK) */
	CPSID	I
 8000690:	b672      	cpsid	i

	/* Clear the PendSV exception (preventing 2nd triggering) */
	LDR	R2, =NVIC_INT_CTRL
 8000692:	4a0d      	ldr	r2, [pc, #52]	; (80006c8 <NMI_Handler+0x10>)
	LDR	R1, =NVIC_PENDSVCLR
 8000694:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
	STR	R1, [R2]
 8000698:	6011      	str	r1, [r2, #0]
	 * EE_std_change_context(EE_TID) at the
	 * end of PendSV_Handler.
	 */

	/* R3 = 0x01000000 (xPSR) */
	LDR	R3, =EPSR_T_BIT_VAL
 800069a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000

	/* R2 = osEE_cortex_m_change_context_from_task_end (PC) */
	LDR	R2, =osEE_cortex_m_change_context_from_task_end
 800069e:	4a0b      	ldr	r2, [pc, #44]	; (80006cc <NMI_Handler+0x14>)

	/* R1 = osEE_cortex_m_thread_end (LR) */
	LDR	R1, =osEE_cortex_m_thread_end
 80006a0:	490b      	ldr	r1, [pc, #44]	; (80006d0 <NMI_Handler+0x18>)
	 * |xPSR|-> xPSR AND 0xFFFFFE0
	 * | PC |-> osEE_cortex_m_change_context_from_task_end
	 * | LR |-> osEE_cortex_m_thread_end
	 * | R12|
	 */
	PUSH	{R0-R3}
 80006a2:	b40f      	push	{r0, r1, r2, r3}
	 * | R3 |
	 * | R2 |
	 * | R1 |
	 * | R0 |
	 */
	PUSH	{R0-R3}
 80006a4:	b40f      	push	{r0, r1, r2, r3}
	/*
	 * R0 = EXC_RETURN -> Return to Thread mode.
	 *		   -> Exception return gets state from MSP.
	 *		   -> Execution uses MSP after return.
	 */
	LDR	LR, =EXC_RETURN
 80006a6:	f06f 0e06 	mvn.w	lr, #6

	BX	LR		/* EXC_RETURN. */
 80006aa:	4770      	bx	lr

080006ac <osEE_cortex_m_thread_end>:
	.global	osEE_cortex_m_thread_end
	.type	osEE_cortex_m_thread_end, %function
osEE_cortex_m_thread_end:

	/* trigger NMI to return to preempted task... */
	LDR	R0, =0xE000ED04	/* Interrupt Control and State Register */
 80006ac:	4806      	ldr	r0, [pc, #24]	; (80006c8 <NMI_Handler+0x10>)
	MOVS	R1, #1
 80006ae:	2101      	movs	r1, #1
	LSLS	R1, R1, #31	/* R0 := (1 << 31) (NMI bit) */
 80006b0:	07c9      	lsls	r1, r1, #31
	STR	R1,[r0]		/* ICSR[31] := 1 (pend NMI) */
 80006b2:	6001      	str	r1, [r0, #0]
	B	.		/* wait for preemption by NMI */
 80006b4:	e7fe      	b.n	80006b4 <osEE_cortex_m_thread_end+0x8>
 80006b6:	bf00      	nop

080006b8 <NMI_Handler>:
	.global	NMI_Handler
	.type	NMI_Handler, %function
NMI_Handler:

	/* Remove SVCall Stack-Frame. */
	ADD	SP, SP, #(8*4)
 80006b8:	b008      	add	sp, #32
	/* Retrieves original Link Register. */
	POP	{R0, LR}
#endif	/* defined(OS_EE_ARCH_CORTEX_M_M7F_FPU) */

	/* Enable interrupts (clear PRIMASK) */
	CPSIE	I
 80006ba:	b662      	cpsie	i

	BX	LR		/* EXC_RETURN. */
 80006bc:	4770      	bx	lr
 80006be:	0000      	.short	0x0000
	LDR	R0, =NVIC_SHPR3
 80006c0:	e000ed20 	.word	0xe000ed20
	LDR	R0, =NVIC_SHPR2
 80006c4:	e000ed1c 	.word	0xe000ed1c
	LDR	R0, =NVIC_INT_CTRL
 80006c8:	e000ed04 	.word	0xe000ed04
	LDR	R2, =osEE_cortex_m_change_context_from_task_end
 80006cc:	080024a1 	.word	0x080024a1
	LDR	R1, =osEE_cortex_m_thread_end
 80006d0:	080006ad 	.word	0x080006ad

080006d4 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 80006d4:	f8df d034 	ldr.w	sp, [pc, #52]	; 800070c <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 80006d8:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 80006da:	e003      	b.n	80006e4 <LoopCopyDataInit>

080006dc <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 80006dc:	4b0c      	ldr	r3, [pc, #48]	; (8000710 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 80006de:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 80006e0:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 80006e2:	3104      	adds	r1, #4

080006e4 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 80006e4:	480b      	ldr	r0, [pc, #44]	; (8000714 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 80006e6:	4b0c      	ldr	r3, [pc, #48]	; (8000718 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 80006e8:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 80006ea:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 80006ec:	d3f6      	bcc.n	80006dc <CopyDataInit>
  ldr  r2, =_sbss
 80006ee:	4a0b      	ldr	r2, [pc, #44]	; (800071c <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 80006f0:	e002      	b.n	80006f8 <LoopFillZerobss>

080006f2 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 80006f2:	2300      	movs	r3, #0
  str  r3, [r2], #4
 80006f4:	f842 3b04 	str.w	r3, [r2], #4

080006f8 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 80006f8:	4b09      	ldr	r3, [pc, #36]	; (8000720 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 80006fa:	429a      	cmp	r2, r3
  bcc  FillZerobss
 80006fc:	d3f9      	bcc.n	80006f2 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 80006fe:	f001 fc23 	bl	8001f48 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8000702:	f000 fb5d 	bl	8000dc0 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8000706:	f000 f875 	bl	80007f4 <main>
  bx  lr    
 800070a:	4770      	bx	lr
  ldr   sp, =_estack     /* set stack pointer */
 800070c:	20020000 	.word	0x20020000
  ldr  r3, =_sidata
 8000710:	080026a8 	.word	0x080026a8
  ldr  r0, =_sdata
 8000714:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8000718:	20000490 	.word	0x20000490
  ldr  r2, =_sbss
 800071c:	20000490 	.word	0x20000490
  ldr  r3, = _ebss
 8000720:	2000094c 	.word	0x2000094c

08000724 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8000724:	e7fe      	b.n	8000724 <ADC_IRQHandler>

08000726 <StartupHook>:

#define	IDLE_STR	(P2CONST(uint8_t, AUTOMATIC, OS_APPL_DATA))"Idle\r\n"


void StartupHook(void)
{
 8000726:	b508      	push	{r3, lr}
	DemoHAL_SerialInit();
 8000728:	f000 f966 	bl	80009f8 <DemoHAL_SerialInit>
}
 800072c:	bd08      	pop	{r3, pc}

0800072e <serial_print>:

void serial_print(char const * msg)
{
 800072e:	b510      	push	{r4, lr}
 8000730:	4604      	mov	r4, r0
  SuspendAllInterrupts();
 8000732:	f001 fc41 	bl	8001fb8 <SuspendAllInterrupts>
  DemoHAL_SerialWrite((uint8_t const *)msg, strlen(msg));
 8000736:	4620      	mov	r0, r4
 8000738:	f7ff fd62 	bl	8000200 <strlen>
 800073c:	4601      	mov	r1, r0
 800073e:	4620      	mov	r0, r4
 8000740:	f000 f91e 	bl	8000980 <DemoHAL_SerialWrite>
  ResumeAllInterrupts();
 8000744:	f001 fc40 	bl	8001fc8 <ResumeAllInterrupts>
}
 8000748:	bd10      	pop	{r4, pc}
	...

0800074c <idle_hook>:
      ;                                                             \
    }                                                               \
  } while ( 0 )

void idle_hook(void)
{
 800074c:	b508      	push	{r3, lr}
	if ( !stk_wrong ) {
 800074e:	4b21      	ldr	r3, [pc, #132]	; (80007d4 <idle_hook+0x88>)
 8000750:	781b      	ldrb	r3, [r3, #0]
 8000752:	b9ab      	cbnz	r3, 8000780 <idle_hook+0x34>
		if (!old_sp) {
 8000754:	4b20      	ldr	r3, [pc, #128]	; (80007d8 <idle_hook+0x8c>)
 8000756:	681b      	ldr	r3, [r3, #0]
 8000758:	b17b      	cbz	r3, 800077a <idle_hook+0x2e>
OSEE_STATIC_INLINE FUNC(OsEE_addr, OS_CODE) OSEE_ALWAYS_INLINE
osEE_get_SP (
void
) {
  VAR(OsEE_addr, AUTOMATIC) temp;
  OSEE_GET_SP(temp);
 800075a:	466b      	mov	r3, sp
			old_sp = osEE_get_SP();
		}
		else if (old_sp != osEE_get_SP()) {
 800075c:	4a1e      	ldr	r2, [pc, #120]	; (80007d8 <idle_hook+0x8c>)
 800075e:	6812      	ldr	r2, [r2, #0]
 8000760:	429a      	cmp	r2, r3
 8000762:	d00d      	beq.n	8000780 <idle_hook+0x34>
			stk_wrong = OSEE_TRUE;
 8000764:	2001      	movs	r0, #1
 8000766:	4b1b      	ldr	r3, [pc, #108]	; (80007d4 <idle_hook+0x88>)
 8000768:	7018      	strb	r0, [r3, #0]
			OSEE_BREAK_POINT();
 800076a:	f000 f913 	bl	8000994 <DemoHAL_LedOn>
 800076e:	f001 fc1b 	bl	8001fa8 <DisableAllInterrupts>
 8000772:	481a      	ldr	r0, [pc, #104]	; (80007dc <idle_hook+0x90>)
 8000774:	f7ff ffdb 	bl	800072e <serial_print>
 8000778:	e7fe      	b.n	8000778 <idle_hook+0x2c>
 800077a:	466a      	mov	r2, sp
			old_sp = osEE_get_SP();
 800077c:	4b16      	ldr	r3, [pc, #88]	; (80007d8 <idle_hook+0x8c>)
 800077e:	601a      	str	r2, [r3, #0]
		}
	}
static int var_test = 0;


var_test++;
 8000780:	4a17      	ldr	r2, [pc, #92]	; (80007e0 <idle_hook+0x94>)
 8000782:	6813      	ldr	r3, [r2, #0]
 8000784:	3301      	adds	r3, #1
 8000786:	6013      	str	r3, [r2, #0]
	++idle_cnt;
 8000788:	4b16      	ldr	r3, [pc, #88]	; (80007e4 <idle_hook+0x98>)
 800078a:	681a      	ldr	r2, [r3, #0]
 800078c:	3201      	adds	r2, #1
 800078e:	601a      	str	r2, [r3, #0]
	if (idle_cnt >= IDLE_CNT_MAX) {
 8000790:	681a      	ldr	r2, [r3, #0]
 8000792:	4b15      	ldr	r3, [pc, #84]	; (80007e8 <idle_hook+0x9c>)
 8000794:	429a      	cmp	r2, r3
 8000796:	d919      	bls.n	80007cc <idle_hook+0x80>
		idle_cnt = 0;
 8000798:	4b12      	ldr	r3, [pc, #72]	; (80007e4 <idle_hook+0x98>)
 800079a:	2200      	movs	r2, #0
 800079c:	601a      	str	r2, [r3, #0]
		task_cnt++;
 800079e:	4b13      	ldr	r3, [pc, #76]	; (80007ec <idle_hook+0xa0>)
 80007a0:	681a      	ldr	r2, [r3, #0]
 80007a2:	3201      	adds	r2, #1
 80007a4:	601a      	str	r2, [r3, #0]
		if(task_cnt == 5){
 80007a6:	681b      	ldr	r3, [r3, #0]
 80007a8:	2b05      	cmp	r3, #5
 80007aa:	d106      	bne.n	80007ba <idle_hook+0x6e>
			ActivateTask(Task2);
 80007ac:	2001      	movs	r0, #1
 80007ae:	f001 fc51 	bl	8002054 <ActivateTask>
			task_cnt = 0;
 80007b2:	4b0e      	ldr	r3, [pc, #56]	; (80007ec <idle_hook+0xa0>)
 80007b4:	2200      	movs	r2, #0
 80007b6:	601a      	str	r2, [r3, #0]
 80007b8:	e002      	b.n	80007c0 <idle_hook+0x74>
		}
		else
			ActivateTask(Task1);
 80007ba:	2000      	movs	r0, #0
 80007bc:	f001 fc4a 	bl	8002054 <ActivateTask>
		DemoHAL_LedToggle(DEMO_HAL_LED_0);
 80007c0:	2000      	movs	r0, #0
 80007c2:	f000 f8ab 	bl	800091c <DemoHAL_LedToggle>
		serial_print(IDLE_STR);
 80007c6:	480a      	ldr	r0, [pc, #40]	; (80007f0 <idle_hook+0xa4>)
 80007c8:	f7ff ffb1 	bl	800072e <serial_print>
	}

	DemoHAL_MainFunction();
 80007cc:	f000 f87c 	bl	80008c8 <DemoHAL_MainFunction>
}
 80007d0:	bd08      	pop	{r3, pc}
 80007d2:	bf00      	nop
 80007d4:	200004b4 	.word	0x200004b4
 80007d8:	200004b0 	.word	0x200004b0
 80007dc:	080024ec 	.word	0x080024ec
 80007e0:	200004bc 	.word	0x200004bc
 80007e4:	200004ac 	.word	0x200004ac
 80007e8:	000f423f 	.word	0x000f423f
 80007ec:	200004b8 	.word	0x200004b8
 80007f0:	08002508 	.word	0x08002508

080007f4 <main>:

int main(void)
{
 80007f4:	b508      	push	{r3, lr}
	DemoHAL_Init();
 80007f6:	f000 f859 	bl	80008ac <DemoHAL_Init>

	DemoHAL_LedInit();
 80007fa:	f000 f951 	bl	8000aa0 <DemoHAL_LedInit>

	DemoHAL_SerialInit();
 80007fe:	f000 f8fb 	bl	80009f8 <DemoHAL_SerialInit>

	//serial_print("STARTING OS\r\n");

	StartOS(OSDEFAULTAPPMODE);
 8000802:	2000      	movs	r0, #0
 8000804:	f001 fbee 	bl	8001fe4 <StartOS>

	return 0;
}
 8000808:	2000      	movs	r0, #0
 800080a:	bd08      	pop	{r3, pc}

0800080c <SystemClock_Config>:
  *            Flash Latency(WS)              = 5
  * @param  None
  * @retval None
  */
static FUNC(void, APPL_CODE) SystemClock_Config(void)
{
 800080c:	b530      	push	{r4, r5, lr}
 800080e:	b095      	sub	sp, #84	; 0x54
	RCC_ClkInitTypeDef RCC_ClkInitStruct;
	RCC_OscInitTypeDef RCC_OscInitStruct;

	/* Enable Power Control clock */
	__HAL_RCC_PWR_CLK_ENABLE();
 8000810:	2400      	movs	r4, #0
 8000812:	9401      	str	r4, [sp, #4]
 8000814:	4b22      	ldr	r3, [pc, #136]	; (80008a0 <SystemClock_Config+0x94>)
 8000816:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000818:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800081c:	641a      	str	r2, [r3, #64]	; 0x40
 800081e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000820:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000824:	9301      	str	r3, [sp, #4]
 8000826:	9b01      	ldr	r3, [sp, #4]

	/* The voltage scaling allows optimizing the power consumption when the device is
       clocked below the maximum system frequency, to update the voltage scaling value
       regarding system frequency refer to product datasheet.  */
	__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8000828:	9402      	str	r4, [sp, #8]
 800082a:	4b1e      	ldr	r3, [pc, #120]	; (80008a4 <SystemClock_Config+0x98>)
 800082c:	681a      	ldr	r2, [r3, #0]
 800082e:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8000832:	601a      	str	r2, [r3, #0]
 8000834:	681b      	ldr	r3, [r3, #0]
 8000836:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800083a:	9302      	str	r3, [sp, #8]
 800083c:	9b02      	ldr	r3, [sp, #8]

	/* Enable HSE Oscillator and activate PLL with HSE as source */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 800083e:	2301      	movs	r3, #1
 8000840:	9303      	str	r3, [sp, #12]
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8000842:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000846:	9304      	str	r3, [sp, #16]
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000848:	2502      	movs	r5, #2
 800084a:	9509      	str	r5, [sp, #36]	; 0x24
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800084c:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8000850:	930a      	str	r3, [sp, #40]	; 0x28
	RCC_OscInitStruct.PLL.PLLM = 8;
 8000852:	2308      	movs	r3, #8
 8000854:	930b      	str	r3, [sp, #44]	; 0x2c
	RCC_OscInitStruct.PLL.PLLN = 336;
 8000856:	f44f 73a8 	mov.w	r3, #336	; 0x150
 800085a:	930c      	str	r3, [sp, #48]	; 0x30
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 800085c:	950d      	str	r5, [sp, #52]	; 0x34
	RCC_OscInitStruct.PLL.PLLQ = 7;
 800085e:	2307      	movs	r3, #7
 8000860:	930e      	str	r3, [sp, #56]	; 0x38
	HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8000862:	a803      	add	r0, sp, #12
 8000864:	f000 fd9c 	bl	80013a0 <HAL_RCC_OscConfig>

	/* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers */
	RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
 8000868:	230f      	movs	r3, #15
 800086a:	930f      	str	r3, [sp, #60]	; 0x3c
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800086c:	9510      	str	r5, [sp, #64]	; 0x40
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800086e:	9411      	str	r4, [sp, #68]	; 0x44
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 8000870:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8000874:	9312      	str	r3, [sp, #72]	; 0x48
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 8000876:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800087a:	9313      	str	r3, [sp, #76]	; 0x4c
	HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
 800087c:	2105      	movs	r1, #5
 800087e:	a80f      	add	r0, sp, #60	; 0x3c
 8000880:	f000 fff0 	bl	8001864 <HAL_RCC_ClockConfig>

	/* STM32F405x/407x/415x/417x Revision Z devices: prefetch is supported  */
	if (HAL_GetREVID() == 0x1001)
 8000884:	f000 fc3a 	bl	80010fc <HAL_GetREVID>
 8000888:	f241 0301 	movw	r3, #4097	; 0x1001
 800088c:	4298      	cmp	r0, r3
 800088e:	d001      	beq.n	8000894 <SystemClock_Config+0x88>
	{
		/* Enable the Flash prefetch */
		__HAL_FLASH_PREFETCH_BUFFER_ENABLE();
	}
}	/* SystemClock_Config() */
 8000890:	b015      	add	sp, #84	; 0x54
 8000892:	bd30      	pop	{r4, r5, pc}
		__HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000894:	4a04      	ldr	r2, [pc, #16]	; (80008a8 <SystemClock_Config+0x9c>)
 8000896:	6813      	ldr	r3, [r2, #0]
 8000898:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800089c:	6013      	str	r3, [r2, #0]
}	/* SystemClock_Config() */
 800089e:	e7f7      	b.n	8000890 <SystemClock_Config+0x84>
 80008a0:	40023800 	.word	0x40023800
 80008a4:	40007000 	.word	0x40007000
 80008a8:	40023c00 	.word	0x40023c00

080008ac <DemoHAL_Init>:
#endif	/* OS_EE_LIB_STM32_CUBE_F4 */

FUNC(void, APPL_CODE) DemoHAL_Init( void )
{
 80008ac:	b508      	push	{r3, lr}
#ifdef	OS_EE_LIB_STM32_CUBE_F4
	HAL_Init();
 80008ae:	f000 fbe9 	bl	8001084 <HAL_Init>

	SystemClock_Config();
 80008b2:	f7ff ffab 	bl	800080c <SystemClock_Config>
#endif	/* OS_EE_LIB_STM32F4XX_DSP_SPL */

#if (defined(OSEE_CORTEX_M_TIM3_ISR) && defined(OSEE_SYSTEM_TIMER))
	DemoHAL_TimerInit(HAL_TIMER_PERIOD_MS);
#endif
}
 80008b6:	bd08      	pop	{r3, pc}

080008b8 <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
FUNC(void, APPL_CODE) SysTick_Handler(void)
{
 80008b8:	b508      	push	{r3, lr}
#ifdef	OS_EE_LIB_STM32_CUBE_F4
	HAL_IncTick();
 80008ba:	f000 fbf9 	bl	80010b0 <HAL_IncTick>
#endif	/* OS_EE_LIB_STM32_CUBE_F4 */
#ifdef	OS_EE_LIB_STM32F4XX_DSP_SPL
	TimingDelay_Decrement();
#endif	/* OS_EE_LIB_STM32F4XX_DSP_SPL */
}
 80008be:	bd08      	pop	{r3, pc}

080008c0 <DemoHAL_Delay>:
#endif	/* OSEE_CORTEX_M_SYSTICK_ISR */

FUNC(void, APPL_CODE) DemoHAL_Delay(
	VAR(MemSize, AUTOMATIC)	interval
)
{
 80008c0:	b508      	push	{r3, lr}
	HAL_Delay(interval);
 80008c2:	f000 fc07 	bl	80010d4 <HAL_Delay>
}
 80008c6:	bd08      	pop	{r3, pc}

080008c8 <DemoHAL_MainFunction>:
#endif
#endif

FUNC(void, APPL_CODE) DemoHAL_MainFunction( void ) {}
 80008c8:	4770      	bx	lr

080008ca <DemoHAL_LedOff>:
}

FUNC(void, APPL_CODE) DemoHAL_LedOff(
	VAR(DemoHAL_Led, AUTOMATIC)	led
)
{
 80008ca:	b508      	push	{r3, lr}
	switch (led) {
 80008cc:	2807      	cmp	r0, #7
 80008ce:	d808      	bhi.n	80008e2 <DemoHAL_LedOff+0x18>
 80008d0:	e8df f000 	tbb	[pc, r0]
 80008d4:	100c0804 	.word	0x100c0804
 80008d8:	201c1814 	.word	0x201c1814
	case DEMO_HAL_LED_0:
#ifdef	OS_EE_LIB_STM32_CUBE_F4
		BSP_LED_Off(LED3);
 80008dc:	2001      	movs	r0, #1
 80008de:	f000 fb8b 	bl	8000ff8 <BSP_LED_Off>
#endif	/* OS_EE_LIB_STM32F4XX_DSP_SPL */
		break;
	default:
		break;
	}
}
 80008e2:	bd08      	pop	{r3, pc}
		BSP_LED_Off(LED3);
 80008e4:	2001      	movs	r0, #1
 80008e6:	f000 fb87 	bl	8000ff8 <BSP_LED_Off>
		break;
 80008ea:	e7fa      	b.n	80008e2 <DemoHAL_LedOff+0x18>
		BSP_LED_Off(LED4);
 80008ec:	2000      	movs	r0, #0
 80008ee:	f000 fb83 	bl	8000ff8 <BSP_LED_Off>
		break;
 80008f2:	e7f6      	b.n	80008e2 <DemoHAL_LedOff+0x18>
		BSP_LED_Off(LED4);
 80008f4:	2000      	movs	r0, #0
 80008f6:	f000 fb7f 	bl	8000ff8 <BSP_LED_Off>
		break;
 80008fa:	e7f2      	b.n	80008e2 <DemoHAL_LedOff+0x18>
		BSP_LED_Off(LED5);
 80008fc:	2002      	movs	r0, #2
 80008fe:	f000 fb7b 	bl	8000ff8 <BSP_LED_Off>
		break;
 8000902:	e7ee      	b.n	80008e2 <DemoHAL_LedOff+0x18>
		BSP_LED_Off(LED5);
 8000904:	2002      	movs	r0, #2
 8000906:	f000 fb77 	bl	8000ff8 <BSP_LED_Off>
		break;
 800090a:	e7ea      	b.n	80008e2 <DemoHAL_LedOff+0x18>
		BSP_LED_Off(LED6);
 800090c:	2003      	movs	r0, #3
 800090e:	f000 fb73 	bl	8000ff8 <BSP_LED_Off>
		break;
 8000912:	e7e6      	b.n	80008e2 <DemoHAL_LedOff+0x18>
		BSP_LED_Off(LED6);
 8000914:	2003      	movs	r0, #3
 8000916:	f000 fb6f 	bl	8000ff8 <BSP_LED_Off>
}
 800091a:	e7e2      	b.n	80008e2 <DemoHAL_LedOff+0x18>

0800091c <DemoHAL_LedToggle>:

FUNC(void, APPL_CODE) DemoHAL_LedToggle(
	VAR(DemoHAL_Led, AUTOMATIC)				led
)
{
 800091c:	b508      	push	{r3, lr}
	switch (led) {
 800091e:	2807      	cmp	r0, #7
 8000920:	d808      	bhi.n	8000934 <DemoHAL_LedToggle+0x18>
 8000922:	e8df f000 	tbb	[pc, r0]
 8000926:	0804      	.short	0x0804
 8000928:	1814100c 	.word	0x1814100c
 800092c:	201c      	.short	0x201c
	case DEMO_HAL_LED_0:
#ifdef	OS_EE_LIB_STM32_CUBE_F4
		BSP_LED_Toggle(LED3);
 800092e:	2001      	movs	r0, #1
 8000930:	f000 fb72 	bl	8001018 <BSP_LED_Toggle>
#endif	/* OS_EE_LIB_STM32F4XX_DSP_SPL */
		break;
	default:
		break;
	}
}
 8000934:	bd08      	pop	{r3, pc}
		BSP_LED_Toggle(LED3);
 8000936:	2001      	movs	r0, #1
 8000938:	f000 fb6e 	bl	8001018 <BSP_LED_Toggle>
		break;
 800093c:	e7fa      	b.n	8000934 <DemoHAL_LedToggle+0x18>
		BSP_LED_Toggle(LED4);
 800093e:	2000      	movs	r0, #0
 8000940:	f000 fb6a 	bl	8001018 <BSP_LED_Toggle>
		break;
 8000944:	e7f6      	b.n	8000934 <DemoHAL_LedToggle+0x18>
		BSP_LED_Toggle(LED4);
 8000946:	2000      	movs	r0, #0
 8000948:	f000 fb66 	bl	8001018 <BSP_LED_Toggle>
		break;
 800094c:	e7f2      	b.n	8000934 <DemoHAL_LedToggle+0x18>
		BSP_LED_Toggle(LED5);
 800094e:	2002      	movs	r0, #2
 8000950:	f000 fb62 	bl	8001018 <BSP_LED_Toggle>
		break;
 8000954:	e7ee      	b.n	8000934 <DemoHAL_LedToggle+0x18>
		BSP_LED_Toggle(LED5);
 8000956:	2002      	movs	r0, #2
 8000958:	f000 fb5e 	bl	8001018 <BSP_LED_Toggle>
		break;
 800095c:	e7ea      	b.n	8000934 <DemoHAL_LedToggle+0x18>
		BSP_LED_Toggle(LED6);
 800095e:	2003      	movs	r0, #3
 8000960:	f000 fb5a 	bl	8001018 <BSP_LED_Toggle>
		break;
 8000964:	e7e6      	b.n	8000934 <DemoHAL_LedToggle+0x18>
		BSP_LED_Toggle(LED6);
 8000966:	2003      	movs	r0, #3
 8000968:	f000 fb56 	bl	8001018 <BSP_LED_Toggle>
}
 800096c:	e7e2      	b.n	8000934 <DemoHAL_LedToggle+0x18>
	...

08000970 <SerialISR>:

static VAR(UART_HandleTypeDef, OS_APPL_DATA)	UartHandle;
#endif	/* OS_EE_LIB_STM32_CUBE_F4 */

ISR1(SerialISR)
{
 8000970:	b508      	push	{r3, lr}
#ifdef	OS_EE_LIB_STM32_CUBE_F4
	HAL_UART_IRQHandler(&UartHandle);
 8000972:	4802      	ldr	r0, [pc, #8]	; (800097c <SerialISR+0xc>)
 8000974:	f001 fa4c 	bl	8001e10 <HAL_UART_IRQHandler>
#endif	/* OS_EE_LIB_STM32_CUBE_F4 */
}
 8000978:	bd08      	pop	{r3, pc}
 800097a:	bf00      	nop
 800097c:	200008d4 	.word	0x200008d4

08000980 <DemoHAL_SerialWrite>:
void DemoHAL_SerialWrite(
	//P2CONST(uint8_t, AUTOMATIC, OS_APPL_DATA)		buffer,
	//VAR(MemSize, AUTOMATIC)					length
	const uint8_t *buffer,
	size_t length
) {
 8000980:	b508      	push	{r3, lr}
#ifdef	OS_EE_LIB_STM32F4XX_DSP_SPL
	(void)buffer;
	(void)length;
#endif	/* OS_EE_LIB_STM32F4XX_DSP_SPL */
#ifdef	OS_EE_LIB_STM32_CUBE_F4
	HAL_UART_Transmit_IT(&UartHandle, (uint8_t *)buffer, length);
 8000982:	b28a      	uxth	r2, r1
 8000984:	4601      	mov	r1, r0
 8000986:	4802      	ldr	r0, [pc, #8]	; (8000990 <DemoHAL_SerialWrite+0x10>)
 8000988:	f001 f9c0 	bl	8001d0c <HAL_UART_Transmit_IT>
#endif	/* OS_EE_LIB_STM32_CUBE_F4 */
}
 800098c:	bd08      	pop	{r3, pc}
 800098e:	bf00      	nop
 8000990:	200008d4 	.word	0x200008d4

08000994 <DemoHAL_LedOn>:
{
 8000994:	b510      	push	{r4, lr}
 8000996:	4604      	mov	r4, r0
	DemoHAL_SerialWrite(halLedArray[led], HAL_LCD_LED_STR_SZ);
 8000998:	2103      	movs	r1, #3
 800099a:	4b16      	ldr	r3, [pc, #88]	; (80009f4 <DemoHAL_LedOn+0x60>)
 800099c:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 80009a0:	f7ff ffee 	bl	8000980 <DemoHAL_SerialWrite>
	switch (led) {
 80009a4:	2c07      	cmp	r4, #7
 80009a6:	d808      	bhi.n	80009ba <DemoHAL_LedOn+0x26>
 80009a8:	e8df f004 	tbb	[pc, r4]
 80009ac:	100c0804 	.word	0x100c0804
 80009b0:	201c1814 	.word	0x201c1814
		BSP_LED_On(LED3);
 80009b4:	2001      	movs	r0, #1
 80009b6:	f000 fb0f 	bl	8000fd8 <BSP_LED_On>
}
 80009ba:	bd10      	pop	{r4, pc}
		BSP_LED_On(LED3);
 80009bc:	2001      	movs	r0, #1
 80009be:	f000 fb0b 	bl	8000fd8 <BSP_LED_On>
		break;
 80009c2:	e7fa      	b.n	80009ba <DemoHAL_LedOn+0x26>
		BSP_LED_On(LED4);
 80009c4:	2000      	movs	r0, #0
 80009c6:	f000 fb07 	bl	8000fd8 <BSP_LED_On>
		break;
 80009ca:	e7f6      	b.n	80009ba <DemoHAL_LedOn+0x26>
		BSP_LED_On(LED4);
 80009cc:	2000      	movs	r0, #0
 80009ce:	f000 fb03 	bl	8000fd8 <BSP_LED_On>
		break;
 80009d2:	e7f2      	b.n	80009ba <DemoHAL_LedOn+0x26>
		BSP_LED_On(LED5);
 80009d4:	2002      	movs	r0, #2
 80009d6:	f000 faff 	bl	8000fd8 <BSP_LED_On>
		break;
 80009da:	e7ee      	b.n	80009ba <DemoHAL_LedOn+0x26>
		BSP_LED_On(LED5);
 80009dc:	2002      	movs	r0, #2
 80009de:	f000 fafb 	bl	8000fd8 <BSP_LED_On>
		break;
 80009e2:	e7ea      	b.n	80009ba <DemoHAL_LedOn+0x26>
		BSP_LED_On(LED6);
 80009e4:	2003      	movs	r0, #3
 80009e6:	f000 faf7 	bl	8000fd8 <BSP_LED_On>
		break;
 80009ea:	e7e6      	b.n	80009ba <DemoHAL_LedOn+0x26>
		BSP_LED_On(LED6);
 80009ec:	2003      	movs	r0, #3
 80009ee:	f000 faf3 	bl	8000fd8 <BSP_LED_On>
}
 80009f2:	e7e2      	b.n	80009ba <DemoHAL_LedOn+0x26>
 80009f4:	080025a0 	.word	0x080025a0

080009f8 <DemoHAL_SerialInit>:
{
 80009f8:	b570      	push	{r4, r5, r6, lr}
 80009fa:	b088      	sub	sp, #32
	USARTx_TX_GPIO_CLK_ENABLE();
 80009fc:	2400      	movs	r4, #0
 80009fe:	9400      	str	r4, [sp, #0]
 8000a00:	4b23      	ldr	r3, [pc, #140]	; (8000a90 <DemoHAL_SerialInit+0x98>)
 8000a02:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000a04:	f042 0201 	orr.w	r2, r2, #1
 8000a08:	631a      	str	r2, [r3, #48]	; 0x30
 8000a0a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000a0c:	f002 0201 	and.w	r2, r2, #1
 8000a10:	9200      	str	r2, [sp, #0]
 8000a12:	9a00      	ldr	r2, [sp, #0]
	USARTx_RX_GPIO_CLK_ENABLE();
 8000a14:	9401      	str	r4, [sp, #4]
 8000a16:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000a18:	f042 0201 	orr.w	r2, r2, #1
 8000a1c:	631a      	str	r2, [r3, #48]	; 0x30
 8000a1e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000a20:	f002 0201 	and.w	r2, r2, #1
 8000a24:	9201      	str	r2, [sp, #4]
 8000a26:	9a01      	ldr	r2, [sp, #4]
	USARTx_CLK_ENABLE();
 8000a28:	9402      	str	r4, [sp, #8]
 8000a2a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000a2c:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8000a30:	641a      	str	r2, [r3, #64]	; 0x40
 8000a32:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000a34:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8000a38:	9302      	str	r3, [sp, #8]
 8000a3a:	9b02      	ldr	r3, [sp, #8]
	GPIO_InitStruct.Pin       = USARTx_TX_PIN;
 8000a3c:	2304      	movs	r3, #4
 8000a3e:	9303      	str	r3, [sp, #12]
	GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 8000a40:	2302      	movs	r3, #2
 8000a42:	9304      	str	r3, [sp, #16]
	GPIO_InitStruct.Pull      = GPIO_NOPULL;
 8000a44:	9405      	str	r4, [sp, #20]
	GPIO_InitStruct.Speed     = GPIO_SPEED_FAST;
 8000a46:	9306      	str	r3, [sp, #24]
	GPIO_InitStruct.Alternate = USARTx_TX_AF;
 8000a48:	2607      	movs	r6, #7
 8000a4a:	9607      	str	r6, [sp, #28]
	HAL_GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStruct);
 8000a4c:	4d11      	ldr	r5, [pc, #68]	; (8000a94 <DemoHAL_SerialInit+0x9c>)
 8000a4e:	a903      	add	r1, sp, #12
 8000a50:	4628      	mov	r0, r5
 8000a52:	f000 fbb5 	bl	80011c0 <HAL_GPIO_Init>
	GPIO_InitStruct.Pin = USARTx_RX_PIN;
 8000a56:	2308      	movs	r3, #8
 8000a58:	9303      	str	r3, [sp, #12]
	GPIO_InitStruct.Alternate = USARTx_RX_AF;
 8000a5a:	9607      	str	r6, [sp, #28]
	HAL_GPIO_Init(USARTx_RX_GPIO_PORT, &GPIO_InitStruct);
 8000a5c:	a903      	add	r1, sp, #12
 8000a5e:	4628      	mov	r0, r5
 8000a60:	f000 fbae 	bl	80011c0 <HAL_GPIO_Init>
	UartHandle.Instance          = USARTx;
 8000a64:	480c      	ldr	r0, [pc, #48]	; (8000a98 <DemoHAL_SerialInit+0xa0>)
 8000a66:	4b0d      	ldr	r3, [pc, #52]	; (8000a9c <DemoHAL_SerialInit+0xa4>)
 8000a68:	6003      	str	r3, [r0, #0]
	UartHandle.Init.BaudRate     = 115200;
 8000a6a:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 8000a6e:	6043      	str	r3, [r0, #4]
	UartHandle.Init.WordLength   = UART_WORDLENGTH_8B;
 8000a70:	6084      	str	r4, [r0, #8]
	UartHandle.Init.StopBits     = UART_STOPBITS_1;
 8000a72:	60c4      	str	r4, [r0, #12]
	UartHandle.Init.Parity       = UART_PARITY_NONE;
 8000a74:	6104      	str	r4, [r0, #16]
	UartHandle.Init.HwFlowCtl    = UART_HWCONTROL_NONE;
 8000a76:	6184      	str	r4, [r0, #24]
	UartHandle.Init.Mode         = UART_MODE_TX_RX;
 8000a78:	230c      	movs	r3, #12
 8000a7a:	6143      	str	r3, [r0, #20]
	UartHandle.Init.OverSampling = UART_OVERSAMPLING_16;
 8000a7c:	61c4      	str	r4, [r0, #28]
	if(HAL_UART_Init(&UartHandle) != HAL_OK)
 8000a7e:	f001 f916 	bl	8001cae <HAL_UART_Init>
 8000a82:	b908      	cbnz	r0, 8000a88 <DemoHAL_SerialInit+0x90>
}
 8000a84:	b008      	add	sp, #32
 8000a86:	bd70      	pop	{r4, r5, r6, pc}
		DemoHAL_LedOn(DEMO_HAL_LED_1);
 8000a88:	2001      	movs	r0, #1
 8000a8a:	f7ff ff83 	bl	8000994 <DemoHAL_LedOn>
 8000a8e:	e7fe      	b.n	8000a8e <DemoHAL_SerialInit+0x96>
 8000a90:	40023800 	.word	0x40023800
 8000a94:	40020000 	.word	0x40020000
 8000a98:	200008d4 	.word	0x200008d4
 8000a9c:	40004400 	.word	0x40004400

08000aa0 <DemoHAL_LedInit>:
{
 8000aa0:	b508      	push	{r3, lr}
	BSP_LED_Init(LED3);
 8000aa2:	2001      	movs	r0, #1
 8000aa4:	f000 fa3e 	bl	8000f24 <BSP_LED_Init>
	BSP_LED_Init(LED4);
 8000aa8:	2000      	movs	r0, #0
 8000aaa:	f000 fa3b 	bl	8000f24 <BSP_LED_Init>
	BSP_LED_Init(LED5);
 8000aae:	2002      	movs	r0, #2
 8000ab0:	f000 fa38 	bl	8000f24 <BSP_LED_Init>
	BSP_LED_Init(LED6);
 8000ab4:	2003      	movs	r0, #3
 8000ab6:	f000 fa35 	bl	8000f24 <BSP_LED_Init>
	DemoHAL_SerialInit();
 8000aba:	f7ff ff9d 	bl	80009f8 <DemoHAL_SerialInit>
}
 8000abe:	bd08      	pop	{r3, pc}

08000ac0 <my_utoa_dec>:

#include "stdio.h"


static void my_utoa_dec(unsigned int value, char *buf)
{
 8000ac0:	b430      	push	{r4, r5}
 8000ac2:	b084      	sub	sp, #16
    char temp[10];
    unsigned int i = 0;

    if (value == 0) {
 8000ac4:	4602      	mov	r2, r0
 8000ac6:	b108      	cbz	r0, 8000acc <my_utoa_dec+0xc>
    unsigned int i = 0;
 8000ac8:	2000      	movs	r0, #0
 8000aca:	e014      	b.n	8000af6 <my_utoa_dec+0x36>
        buf[0] = '0';
 8000acc:	2330      	movs	r3, #48	; 0x30
 8000ace:	700b      	strb	r3, [r1, #0]
        buf[1] = '\0';
 8000ad0:	2300      	movs	r3, #0
 8000ad2:	704b      	strb	r3, [r1, #1]
 8000ad4:	e020      	b.n	8000b18 <my_utoa_dec+0x58>
        return;
    }

    while (value && i < sizeof(temp)) {
        temp[i++] = '0' + (value % 10);
 8000ad6:	4b12      	ldr	r3, [pc, #72]	; (8000b20 <my_utoa_dec+0x60>)
 8000ad8:	fba3 4302 	umull	r4, r3, r3, r2
 8000adc:	08db      	lsrs	r3, r3, #3
 8000ade:	461d      	mov	r5, r3
 8000ae0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8000ae4:	005c      	lsls	r4, r3, #1
 8000ae6:	1b13      	subs	r3, r2, r4
 8000ae8:	3330      	adds	r3, #48	; 0x30
 8000aea:	aa04      	add	r2, sp, #16
 8000aec:	4402      	add	r2, r0
 8000aee:	f802 3c0c 	strb.w	r3, [r2, #-12]
        value /= 10;
 8000af2:	462a      	mov	r2, r5
        temp[i++] = '0' + (value % 10);
 8000af4:	3001      	adds	r0, #1
    while (value && i < sizeof(temp)) {
 8000af6:	b15a      	cbz	r2, 8000b10 <my_utoa_dec+0x50>
 8000af8:	2809      	cmp	r0, #9
 8000afa:	d9ec      	bls.n	8000ad6 <my_utoa_dec+0x16>
 8000afc:	2200      	movs	r2, #0
 8000afe:	e007      	b.n	8000b10 <my_utoa_dec+0x50>
    }

    for (unsigned int j = 0; j < i; ++j) {
        buf[j] = temp[i - j - 1];
 8000b00:	1a83      	subs	r3, r0, r2
 8000b02:	3b01      	subs	r3, #1
 8000b04:	ac04      	add	r4, sp, #16
 8000b06:	4423      	add	r3, r4
 8000b08:	f813 3c0c 	ldrb.w	r3, [r3, #-12]
 8000b0c:	548b      	strb	r3, [r1, r2]
    for (unsigned int j = 0; j < i; ++j) {
 8000b0e:	3201      	adds	r2, #1
 8000b10:	4290      	cmp	r0, r2
 8000b12:	d8f5      	bhi.n	8000b00 <my_utoa_dec+0x40>
    }

    buf[i] = '\0';
 8000b14:	2300      	movs	r3, #0
 8000b16:	540b      	strb	r3, [r1, r0]
}
 8000b18:	b004      	add	sp, #16
 8000b1a:	bc30      	pop	{r4, r5}
 8000b1c:	4770      	bx	lr
 8000b1e:	bf00      	nop
 8000b20:	cccccccd 	.word	0xcccccccd

08000b24 <my_utoa_hex>:

static void my_utoa_hex(unsigned int value, char *buf)
{
 8000b24:	b410      	push	{r4}
 8000b26:	b083      	sub	sp, #12
    static const char hex_chars[] = "0123456789ABCDEF";
    char temp[8];
    unsigned int i = 0;

    if (value == 0) {
 8000b28:	4603      	mov	r3, r0
 8000b2a:	b108      	cbz	r0, 8000b30 <my_utoa_hex+0xc>
    unsigned int i = 0;
 8000b2c:	2000      	movs	r0, #0
 8000b2e:	e00e      	b.n	8000b4e <my_utoa_hex+0x2a>
        buf[0] = '0';
 8000b30:	2330      	movs	r3, #48	; 0x30
 8000b32:	700b      	strb	r3, [r1, #0]
        buf[1] = '\0';
 8000b34:	2300      	movs	r3, #0
 8000b36:	704b      	strb	r3, [r1, #1]
 8000b38:	e01a      	b.n	8000b70 <my_utoa_hex+0x4c>
        return;
    }

    while (value && i < sizeof(temp)) {
        temp[i++] = hex_chars[value & 0xF];
 8000b3a:	f003 020f 	and.w	r2, r3, #15
 8000b3e:	4c0e      	ldr	r4, [pc, #56]	; (8000b78 <my_utoa_hex+0x54>)
 8000b40:	5ca4      	ldrb	r4, [r4, r2]
 8000b42:	aa02      	add	r2, sp, #8
 8000b44:	4402      	add	r2, r0
 8000b46:	f802 4c08 	strb.w	r4, [r2, #-8]
        value >>= 4;
 8000b4a:	091b      	lsrs	r3, r3, #4
        temp[i++] = hex_chars[value & 0xF];
 8000b4c:	3001      	adds	r0, #1
    while (value && i < sizeof(temp)) {
 8000b4e:	b15b      	cbz	r3, 8000b68 <my_utoa_hex+0x44>
 8000b50:	2807      	cmp	r0, #7
 8000b52:	d9f2      	bls.n	8000b3a <my_utoa_hex+0x16>
 8000b54:	2300      	movs	r3, #0
 8000b56:	e007      	b.n	8000b68 <my_utoa_hex+0x44>
    }

    for (unsigned int j = 0; j < i; ++j) {
        buf[j] = temp[i - j - 1];
 8000b58:	1ac2      	subs	r2, r0, r3
 8000b5a:	3a01      	subs	r2, #1
 8000b5c:	ac02      	add	r4, sp, #8
 8000b5e:	4422      	add	r2, r4
 8000b60:	f812 2c08 	ldrb.w	r2, [r2, #-8]
 8000b64:	54ca      	strb	r2, [r1, r3]
    for (unsigned int j = 0; j < i; ++j) {
 8000b66:	3301      	adds	r3, #1
 8000b68:	4298      	cmp	r0, r3
 8000b6a:	d8f5      	bhi.n	8000b58 <my_utoa_hex+0x34>
    }

    buf[i] = '\0';
 8000b6c:	2300      	movs	r3, #0
 8000b6e:	540b      	strb	r3, [r1, r0]
}
 8000b70:	b003      	add	sp, #12
 8000b72:	bc10      	pop	{r4}
 8000b74:	4770      	bx	lr
 8000b76:	bf00      	nop
 8000b78:	080025d8 	.word	0x080025d8

08000b7c <my_format>:
int my_format(char *out_buf, size_t max_len, const char *fmt, __builtin_va_list args)
{
 8000b7c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8000b80:	b087      	sub	sp, #28
 8000b82:	4606      	mov	r6, r0
 8000b84:	4688      	mov	r8, r1
 8000b86:	9301      	str	r3, [sp, #4]
    const char *p = fmt;
    char *out = out_buf;
 8000b88:	4604      	mov	r4, r0
    char num_buf[16];

    while (*p && (size_t)(out - out_buf) < max_len - 1) {
 8000b8a:	e057      	b.n	8000c3c <my_format+0xc0>
        if (*p == '%') {
            p++;
 8000b8c:	f102 0901 	add.w	r9, r2, #1
            switch (*p) {
 8000b90:	7853      	ldrb	r3, [r2, #1]
 8000b92:	3b63      	subs	r3, #99	; 0x63
 8000b94:	2b15      	cmp	r3, #21
 8000b96:	d85e      	bhi.n	8000c56 <my_format+0xda>
 8000b98:	e8df f003 	tbb	[pc, r3]
 8000b9c:	5d5d0b48 	.word	0x5d5d0b48
 8000ba0:	5d5d5d5d 	.word	0x5d5d5d5d
 8000ba4:	5d5d5d5d 	.word	0x5d5d5d5d
 8000ba8:	5d5d5d5d 	.word	0x5d5d5d5d
 8000bac:	5d5d5d39 	.word	0x5d5d5d39
 8000bb0:	265d      	.short	0x265d
                case 'd': {
                    int val = __builtin_va_arg(args, int);
 8000bb2:	9b01      	ldr	r3, [sp, #4]
 8000bb4:	1d1a      	adds	r2, r3, #4
 8000bb6:	9201      	str	r2, [sp, #4]
 8000bb8:	6818      	ldr	r0, [r3, #0]
                    if (val < 0) {
 8000bba:	2800      	cmp	r0, #0
 8000bbc:	db04      	blt.n	8000bc8 <my_format+0x4c>
                        *out++ = '-';
                        val = -val;
                    }
                    my_utoa_dec((unsigned int)val, num_buf);
 8000bbe:	a902      	add	r1, sp, #8
 8000bc0:	f7ff ff7e 	bl	8000ac0 <my_utoa_dec>
                    for (char *n = num_buf; *n && (size_t)(out - out_buf) < max_len - 1; ++n)
 8000bc4:	ab02      	add	r3, sp, #8
 8000bc6:	e007      	b.n	8000bd8 <my_format+0x5c>
                        *out++ = '-';
 8000bc8:	232d      	movs	r3, #45	; 0x2d
 8000bca:	7023      	strb	r3, [r4, #0]
                        val = -val;
 8000bcc:	4240      	negs	r0, r0
                        *out++ = '-';
 8000bce:	3401      	adds	r4, #1
 8000bd0:	e7f5      	b.n	8000bbe <my_format+0x42>
                        *out++ = *n;
 8000bd2:	7022      	strb	r2, [r4, #0]
                    for (char *n = num_buf; *n && (size_t)(out - out_buf) < max_len - 1; ++n)
 8000bd4:	3301      	adds	r3, #1
                        *out++ = *n;
 8000bd6:	3401      	adds	r4, #1
                    for (char *n = num_buf; *n && (size_t)(out - out_buf) < max_len - 1; ++n)
 8000bd8:	781a      	ldrb	r2, [r3, #0]
 8000bda:	2a00      	cmp	r2, #0
 8000bdc:	d044      	beq.n	8000c68 <my_format+0xec>
 8000bde:	1be1      	subs	r1, r4, r7
 8000be0:	42a9      	cmp	r1, r5
 8000be2:	d3f6      	bcc.n	8000bd2 <my_format+0x56>
            p++;
 8000be4:	464a      	mov	r2, r9
 8000be6:	e028      	b.n	8000c3a <my_format+0xbe>
                    break;
                }
                case 'x': {
                    unsigned int val = __builtin_va_arg(args, unsigned int);
 8000be8:	9b01      	ldr	r3, [sp, #4]
 8000bea:	1d1a      	adds	r2, r3, #4
 8000bec:	9201      	str	r2, [sp, #4]
                    my_utoa_hex(val, num_buf);
 8000bee:	a902      	add	r1, sp, #8
 8000bf0:	6818      	ldr	r0, [r3, #0]
 8000bf2:	f7ff ff97 	bl	8000b24 <my_utoa_hex>
                    for (char *n = num_buf; *n && (size_t)(out - out_buf) < max_len - 1; ++n)
 8000bf6:	ab02      	add	r3, sp, #8
 8000bf8:	e002      	b.n	8000c00 <my_format+0x84>
                        *out++ = *n;
 8000bfa:	7022      	strb	r2, [r4, #0]
                    for (char *n = num_buf; *n && (size_t)(out - out_buf) < max_len - 1; ++n)
 8000bfc:	3301      	adds	r3, #1
                        *out++ = *n;
 8000bfe:	3401      	adds	r4, #1
                    for (char *n = num_buf; *n && (size_t)(out - out_buf) < max_len - 1; ++n)
 8000c00:	781a      	ldrb	r2, [r3, #0]
 8000c02:	b39a      	cbz	r2, 8000c6c <my_format+0xf0>
 8000c04:	1be1      	subs	r1, r4, r7
 8000c06:	42a9      	cmp	r1, r5
 8000c08:	d3f7      	bcc.n	8000bfa <my_format+0x7e>
            p++;
 8000c0a:	464a      	mov	r2, r9
 8000c0c:	e015      	b.n	8000c3a <my_format+0xbe>
                    break;
                }
                case 's': {
                    char *str = __builtin_va_arg(args, char*);
 8000c0e:	9b01      	ldr	r3, [sp, #4]
 8000c10:	1d1a      	adds	r2, r3, #4
 8000c12:	9201      	str	r2, [sp, #4]
 8000c14:	681a      	ldr	r2, [r3, #0]
                    while (*str && (size_t)(out - out_buf) < max_len - 1)
 8000c16:	e002      	b.n	8000c1e <my_format+0xa2>
                        *out++ = *str++;
 8000c18:	3201      	adds	r2, #1
 8000c1a:	7023      	strb	r3, [r4, #0]
 8000c1c:	3401      	adds	r4, #1
                    while (*str && (size_t)(out - out_buf) < max_len - 1)
 8000c1e:	7813      	ldrb	r3, [r2, #0]
 8000c20:	b333      	cbz	r3, 8000c70 <my_format+0xf4>
 8000c22:	1be1      	subs	r1, r4, r7
 8000c24:	42a9      	cmp	r1, r5
 8000c26:	d3f7      	bcc.n	8000c18 <my_format+0x9c>
            p++;
 8000c28:	464a      	mov	r2, r9
 8000c2a:	e006      	b.n	8000c3a <my_format+0xbe>
                    break;
                }
                case 'c': {
                    char ch = (char)__builtin_va_arg(args, int);
 8000c2c:	9b01      	ldr	r3, [sp, #4]
 8000c2e:	1d1a      	adds	r2, r3, #4
 8000c30:	9201      	str	r2, [sp, #4]
 8000c32:	781b      	ldrb	r3, [r3, #0]
                    *out++ = ch;
 8000c34:	7023      	strb	r3, [r4, #0]
 8000c36:	3401      	adds	r4, #1
            p++;
 8000c38:	464a      	mov	r2, r9
                    *out++ = *p;
            }
        } else {
            *out++ = *p;
        }
        p++;
 8000c3a:	3201      	adds	r2, #1
    while (*p && (size_t)(out - out_buf) < max_len - 1) {
 8000c3c:	7811      	ldrb	r1, [r2, #0]
 8000c3e:	b1c9      	cbz	r1, 8000c74 <my_format+0xf8>
 8000c40:	4637      	mov	r7, r6
 8000c42:	1ba3      	subs	r3, r4, r6
 8000c44:	f108 35ff 	add.w	r5, r8, #4294967295	; 0xffffffff
 8000c48:	42ab      	cmp	r3, r5
 8000c4a:	d213      	bcs.n	8000c74 <my_format+0xf8>
        if (*p == '%') {
 8000c4c:	2925      	cmp	r1, #37	; 0x25
 8000c4e:	d09d      	beq.n	8000b8c <my_format+0x10>
            *out++ = *p;
 8000c50:	7021      	strb	r1, [r4, #0]
 8000c52:	3401      	adds	r4, #1
 8000c54:	e7f1      	b.n	8000c3a <my_format+0xbe>
                    *out++ = '%';
 8000c56:	4623      	mov	r3, r4
 8000c58:	2125      	movs	r1, #37	; 0x25
 8000c5a:	f803 1b02 	strb.w	r1, [r3], #2
                    *out++ = *p;
 8000c5e:	7852      	ldrb	r2, [r2, #1]
 8000c60:	7062      	strb	r2, [r4, #1]
 8000c62:	461c      	mov	r4, r3
            p++;
 8000c64:	464a      	mov	r2, r9
 8000c66:	e7e8      	b.n	8000c3a <my_format+0xbe>
 8000c68:	464a      	mov	r2, r9
 8000c6a:	e7e6      	b.n	8000c3a <my_format+0xbe>
 8000c6c:	464a      	mov	r2, r9
 8000c6e:	e7e4      	b.n	8000c3a <my_format+0xbe>
 8000c70:	464a      	mov	r2, r9
 8000c72:	e7e2      	b.n	8000c3a <my_format+0xbe>
    }

    *out = '\0';
 8000c74:	2300      	movs	r3, #0
 8000c76:	7023      	strb	r3, [r4, #0]
    return (int)(out - out_buf);
}
 8000c78:	1ba0      	subs	r0, r4, r6
 8000c7a:	b007      	add	sp, #28
 8000c7c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08000c80 <my_printf>:


void my_printf(const char *fmt, ...)
{
 8000c80:	b40f      	push	{r0, r1, r2, r3}
 8000c82:	b500      	push	{lr}
 8000c84:	b0a3      	sub	sp, #140	; 0x8c
 8000c86:	ab24      	add	r3, sp, #144	; 0x90
 8000c88:	f853 2b04 	ldr.w	r2, [r3], #4
    char buf[128];

    __builtin_va_list args;
    __builtin_va_start(args, fmt);
 8000c8c:	9301      	str	r3, [sp, #4]
    my_format(buf, sizeof(buf), fmt, args);
 8000c8e:	2180      	movs	r1, #128	; 0x80
 8000c90:	a802      	add	r0, sp, #8
 8000c92:	f7ff ff73 	bl	8000b7c <my_format>
    __builtin_va_end(args);

    serial_print(buf);
 8000c96:	a802      	add	r0, sp, #8
 8000c98:	f7ff fd49 	bl	800072e <serial_print>
}
 8000c9c:	b023      	add	sp, #140	; 0x8c
 8000c9e:	f85d eb04 	ldr.w	lr, [sp], #4
 8000ca2:	b004      	add	sp, #16
 8000ca4:	4770      	bx	lr
	...

08000ca8 <FuncTask1>:
      ;                                                             \
    }                                                               \
  } while ( 0 )

TASK(Task1)
{
 8000ca8:	b500      	push	{lr}
 8000caa:	b083      	sub	sp, #12
	static OsEE_bool volatile stk_wrong = OSEE_FALSE;
	static OsEE_addr volatile old_sp = 0;

	serial_print(TASK_STR);
 8000cac:	481e      	ldr	r0, [pc, #120]	; (8000d28 <FuncTask1+0x80>)
 8000cae:	f7ff fd3e 	bl	800072e <serial_print>

	DemoHAL_LedOn(DEMO_HAL_LED_7);
 8000cb2:	2007      	movs	r0, #7
 8000cb4:	f7ff fe6e 	bl	8000994 <DemoHAL_LedOn>

	DemoHAL_Delay(HAL_DELAY_MS);
 8000cb8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8000cbc:	f7ff fe00 	bl	80008c0 <DemoHAL_Delay>

	const char *msg = "UART2";
	char ch = 'H';
	unsigned int u_int = 20;

	my_printf("STRING TEST, Task: %d\r\n msg: %s, ch: %c, hex: %d", Task1_count, msg, ch, u_int);
 8000cc0:	4b1a      	ldr	r3, [pc, #104]	; (8000d2c <FuncTask1+0x84>)
 8000cc2:	8819      	ldrh	r1, [r3, #0]
 8000cc4:	2314      	movs	r3, #20
 8000cc6:	9300      	str	r3, [sp, #0]
 8000cc8:	2348      	movs	r3, #72	; 0x48
 8000cca:	4a19      	ldr	r2, [pc, #100]	; (8000d30 <FuncTask1+0x88>)
 8000ccc:	4819      	ldr	r0, [pc, #100]	; (8000d34 <FuncTask1+0x8c>)
 8000cce:	f7ff ffd7 	bl	8000c80 <my_printf>

	DemoHAL_LedOff(DEMO_HAL_LED_7);
 8000cd2:	2007      	movs	r0, #7
 8000cd4:	f7ff fdf9 	bl	80008ca <DemoHAL_LedOff>

	DemoHAL_Delay(HAL_DELAY_MS);
 8000cd8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8000cdc:	f7ff fdf0 	bl	80008c0 <DemoHAL_Delay>

	if ( !stk_wrong ) {
 8000ce0:	4b15      	ldr	r3, [pc, #84]	; (8000d38 <FuncTask1+0x90>)
 8000ce2:	781b      	ldrb	r3, [r3, #0]
 8000ce4:	b92b      	cbnz	r3, 8000cf2 <FuncTask1+0x4a>
		if (!old_sp) {
 8000ce6:	4b15      	ldr	r3, [pc, #84]	; (8000d3c <FuncTask1+0x94>)
 8000ce8:	681b      	ldr	r3, [r3, #0]
 8000cea:	b963      	cbnz	r3, 8000d06 <FuncTask1+0x5e>
 8000cec:	466a      	mov	r2, sp
			old_sp = osEE_get_SP();
 8000cee:	4b13      	ldr	r3, [pc, #76]	; (8000d3c <FuncTask1+0x94>)
 8000cf0:	601a      	str	r2, [r3, #0]
			stk_wrong = OSEE_TRUE;
			OSEE_BREAK_POINT();
		}
	}

	++Task1_count;
 8000cf2:	4a0e      	ldr	r2, [pc, #56]	; (8000d2c <FuncTask1+0x84>)
 8000cf4:	8813      	ldrh	r3, [r2, #0]
 8000cf6:	3301      	adds	r3, #1
 8000cf8:	b29b      	uxth	r3, r3
 8000cfa:	8013      	strh	r3, [r2, #0]

	TerminateTask();
 8000cfc:	f001 f9d6 	bl	80020ac <TerminateTask>
}
 8000d00:	b003      	add	sp, #12
 8000d02:	f85d fb04 	ldr.w	pc, [sp], #4
 8000d06:	466b      	mov	r3, sp
		else if (old_sp != osEE_get_SP()) {
 8000d08:	4a0c      	ldr	r2, [pc, #48]	; (8000d3c <FuncTask1+0x94>)
 8000d0a:	6812      	ldr	r2, [r2, #0]
 8000d0c:	429a      	cmp	r2, r3
 8000d0e:	d0f0      	beq.n	8000cf2 <FuncTask1+0x4a>
			stk_wrong = OSEE_TRUE;
 8000d10:	2001      	movs	r0, #1
 8000d12:	4b09      	ldr	r3, [pc, #36]	; (8000d38 <FuncTask1+0x90>)
 8000d14:	7018      	strb	r0, [r3, #0]
			OSEE_BREAK_POINT();
 8000d16:	f7ff fe3d 	bl	8000994 <DemoHAL_LedOn>
 8000d1a:	f001 f945 	bl	8001fa8 <DisableAllInterrupts>
 8000d1e:	4808      	ldr	r0, [pc, #32]	; (8000d40 <FuncTask1+0x98>)
 8000d20:	f7ff fd05 	bl	800072e <serial_print>
 8000d24:	e7fe      	b.n	8000d24 <FuncTask1+0x7c>
 8000d26:	bf00      	nop
 8000d28:	080025ec 	.word	0x080025ec
 8000d2c:	20000914 	.word	0x20000914
 8000d30:	080025f4 	.word	0x080025f4
 8000d34:	080025fc 	.word	0x080025fc
 8000d38:	20000920 	.word	0x20000920
 8000d3c:	20000918 	.word	0x20000918
 8000d40:	08002630 	.word	0x08002630

08000d44 <FuncTask2>:

TASK(Task2)
{
 8000d44:	b508      	push	{r3, lr}
	static OsEE_bool volatile stk_wrong = OSEE_FALSE;
	static OsEE_addr volatile old_sp = 0;

	serial_print("Task2\r\n");
 8000d46:	4819      	ldr	r0, [pc, #100]	; (8000dac <FuncTask2+0x68>)
 8000d48:	f7ff fcf1 	bl	800072e <serial_print>

	DemoHAL_LedOn(DEMO_HAL_LED_4);
 8000d4c:	2004      	movs	r0, #4
 8000d4e:	f7ff fe21 	bl	8000994 <DemoHAL_LedOn>

	DemoHAL_Delay(HAL_DELAY_MS);
 8000d52:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8000d56:	f7ff fdb3 	bl	80008c0 <DemoHAL_Delay>

	DemoHAL_LedOff(DEMO_HAL_LED_4);
 8000d5a:	2004      	movs	r0, #4
 8000d5c:	f7ff fdb5 	bl	80008ca <DemoHAL_LedOff>

	DemoHAL_Delay(HAL_DELAY_MS);
 8000d60:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8000d64:	f7ff fdac 	bl	80008c0 <DemoHAL_Delay>

	if ( !stk_wrong ) {
 8000d68:	4b11      	ldr	r3, [pc, #68]	; (8000db0 <FuncTask2+0x6c>)
 8000d6a:	781b      	ldrb	r3, [r3, #0]
 8000d6c:	b92b      	cbnz	r3, 8000d7a <FuncTask2+0x36>
		if (!old_sp) {
 8000d6e:	4b11      	ldr	r3, [pc, #68]	; (8000db4 <FuncTask2+0x70>)
 8000d70:	681b      	ldr	r3, [r3, #0]
 8000d72:	b953      	cbnz	r3, 8000d8a <FuncTask2+0x46>
 8000d74:	466a      	mov	r2, sp
			old_sp = osEE_get_SP();
 8000d76:	4b0f      	ldr	r3, [pc, #60]	; (8000db4 <FuncTask2+0x70>)
 8000d78:	601a      	str	r2, [r3, #0]
			stk_wrong = OSEE_TRUE;
			OSEE_BREAK_POINT();
		}
	}

	++Task2_count;
 8000d7a:	4a0f      	ldr	r2, [pc, #60]	; (8000db8 <FuncTask2+0x74>)
 8000d7c:	8813      	ldrh	r3, [r2, #0]
 8000d7e:	3301      	adds	r3, #1
 8000d80:	b29b      	uxth	r3, r3
 8000d82:	8013      	strh	r3, [r2, #0]

	TerminateTask();
 8000d84:	f001 f992 	bl	80020ac <TerminateTask>
}
 8000d88:	bd08      	pop	{r3, pc}
 8000d8a:	466b      	mov	r3, sp
		else if (old_sp != osEE_get_SP()) {
 8000d8c:	4a09      	ldr	r2, [pc, #36]	; (8000db4 <FuncTask2+0x70>)
 8000d8e:	6812      	ldr	r2, [r2, #0]
 8000d90:	429a      	cmp	r2, r3
 8000d92:	d0f2      	beq.n	8000d7a <FuncTask2+0x36>
			stk_wrong = OSEE_TRUE;
 8000d94:	2001      	movs	r0, #1
 8000d96:	4b06      	ldr	r3, [pc, #24]	; (8000db0 <FuncTask2+0x6c>)
 8000d98:	7018      	strb	r0, [r3, #0]
			OSEE_BREAK_POINT();
 8000d9a:	f7ff fdfb 	bl	8000994 <DemoHAL_LedOn>
 8000d9e:	f001 f903 	bl	8001fa8 <DisableAllInterrupts>
 8000da2:	4806      	ldr	r0, [pc, #24]	; (8000dbc <FuncTask2+0x78>)
 8000da4:	f7ff fcc3 	bl	800072e <serial_print>
 8000da8:	e7fe      	b.n	8000da8 <FuncTask2+0x64>
 8000daa:	bf00      	nop
 8000dac:	0800264c 	.word	0x0800264c
 8000db0:	20000921 	.word	0x20000921
 8000db4:	2000091c 	.word	0x2000091c
 8000db8:	20000916 	.word	0x20000916
 8000dbc:	08002654 	.word	0x08002654

08000dc0 <__libc_init_array>:
 8000dc0:	b570      	push	{r4, r5, r6, lr}
 8000dc2:	4e0d      	ldr	r6, [pc, #52]	; (8000df8 <__libc_init_array+0x38>)
 8000dc4:	4d0d      	ldr	r5, [pc, #52]	; (8000dfc <__libc_init_array+0x3c>)
 8000dc6:	1b76      	subs	r6, r6, r5
 8000dc8:	10b6      	asrs	r6, r6, #2
 8000dca:	d006      	beq.n	8000dda <__libc_init_array+0x1a>
 8000dcc:	2400      	movs	r4, #0
 8000dce:	3401      	adds	r4, #1
 8000dd0:	f855 3b04 	ldr.w	r3, [r5], #4
 8000dd4:	4798      	blx	r3
 8000dd6:	42a6      	cmp	r6, r4
 8000dd8:	d1f9      	bne.n	8000dce <__libc_init_array+0xe>
 8000dda:	4e09      	ldr	r6, [pc, #36]	; (8000e00 <__libc_init_array+0x40>)
 8000ddc:	4d09      	ldr	r5, [pc, #36]	; (8000e04 <__libc_init_array+0x44>)
 8000dde:	1b76      	subs	r6, r6, r5
 8000de0:	f001 fb78 	bl	80024d4 <_init>
 8000de4:	10b6      	asrs	r6, r6, #2
 8000de6:	d006      	beq.n	8000df6 <__libc_init_array+0x36>
 8000de8:	2400      	movs	r4, #0
 8000dea:	3401      	adds	r4, #1
 8000dec:	f855 3b04 	ldr.w	r3, [r5], #4
 8000df0:	4798      	blx	r3
 8000df2:	42a6      	cmp	r6, r4
 8000df4:	d1f9      	bne.n	8000dea <__libc_init_array+0x2a>
 8000df6:	bd70      	pop	{r4, r5, r6, pc}
 8000df8:	0800269c 	.word	0x0800269c
 8000dfc:	0800269c 	.word	0x0800269c
 8000e00:	080026a4 	.word	0x080026a4
 8000e04:	0800269c 	.word	0x0800269c

08000e08 <register_fini>:
 8000e08:	4b02      	ldr	r3, [pc, #8]	; (8000e14 <register_fini+0xc>)
 8000e0a:	b113      	cbz	r3, 8000e12 <register_fini+0xa>
 8000e0c:	4802      	ldr	r0, [pc, #8]	; (8000e18 <register_fini+0x10>)
 8000e0e:	f000 b805 	b.w	8000e1c <atexit>
 8000e12:	4770      	bx	lr
 8000e14:	00000000 	.word	0x00000000
 8000e18:	08000e29 	.word	0x08000e29

08000e1c <atexit>:
 8000e1c:	2300      	movs	r3, #0
 8000e1e:	4601      	mov	r1, r0
 8000e20:	461a      	mov	r2, r3
 8000e22:	4618      	mov	r0, r3
 8000e24:	f000 b81e 	b.w	8000e64 <__register_exitproc>

08000e28 <__libc_fini_array>:
 8000e28:	b538      	push	{r3, r4, r5, lr}
 8000e2a:	4c0a      	ldr	r4, [pc, #40]	; (8000e54 <__libc_fini_array+0x2c>)
 8000e2c:	4d0a      	ldr	r5, [pc, #40]	; (8000e58 <__libc_fini_array+0x30>)
 8000e2e:	1b64      	subs	r4, r4, r5
 8000e30:	10a4      	asrs	r4, r4, #2
 8000e32:	d00a      	beq.n	8000e4a <__libc_fini_array+0x22>
 8000e34:	f104 4380 	add.w	r3, r4, #1073741824	; 0x40000000
 8000e38:	3b01      	subs	r3, #1
 8000e3a:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 8000e3e:	3c01      	subs	r4, #1
 8000e40:	f855 3904 	ldr.w	r3, [r5], #-4
 8000e44:	4798      	blx	r3
 8000e46:	2c00      	cmp	r4, #0
 8000e48:	d1f9      	bne.n	8000e3e <__libc_fini_array+0x16>
 8000e4a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8000e4e:	f001 bb47 	b.w	80024e0 <_fini>
 8000e52:	bf00      	nop
 8000e54:	080026a8 	.word	0x080026a8
 8000e58:	080026a4 	.word	0x080026a4

08000e5c <__retarget_lock_acquire_recursive>:
 8000e5c:	4770      	bx	lr
 8000e5e:	bf00      	nop

08000e60 <__retarget_lock_release_recursive>:
 8000e60:	4770      	bx	lr
 8000e62:	bf00      	nop

08000e64 <__register_exitproc>:
 8000e64:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8000e68:	4d2b      	ldr	r5, [pc, #172]	; (8000f18 <__register_exitproc+0xb4>)
 8000e6a:	4606      	mov	r6, r0
 8000e6c:	6828      	ldr	r0, [r5, #0]
 8000e6e:	4698      	mov	r8, r3
 8000e70:	460f      	mov	r7, r1
 8000e72:	4691      	mov	r9, r2
 8000e74:	f7ff fff2 	bl	8000e5c <__retarget_lock_acquire_recursive>
 8000e78:	4b28      	ldr	r3, [pc, #160]	; (8000f1c <__register_exitproc+0xb8>)
 8000e7a:	681c      	ldr	r4, [r3, #0]
 8000e7c:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
 8000e80:	2b00      	cmp	r3, #0
 8000e82:	d03d      	beq.n	8000f00 <__register_exitproc+0x9c>
 8000e84:	685a      	ldr	r2, [r3, #4]
 8000e86:	2a1f      	cmp	r2, #31
 8000e88:	dc0d      	bgt.n	8000ea6 <__register_exitproc+0x42>
 8000e8a:	f102 0c01 	add.w	ip, r2, #1
 8000e8e:	bb16      	cbnz	r6, 8000ed6 <__register_exitproc+0x72>
 8000e90:	3202      	adds	r2, #2
 8000e92:	f8c3 c004 	str.w	ip, [r3, #4]
 8000e96:	6828      	ldr	r0, [r5, #0]
 8000e98:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
 8000e9c:	f7ff ffe0 	bl	8000e60 <__retarget_lock_release_recursive>
 8000ea0:	2000      	movs	r0, #0
 8000ea2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8000ea6:	4b1e      	ldr	r3, [pc, #120]	; (8000f20 <__register_exitproc+0xbc>)
 8000ea8:	b37b      	cbz	r3, 8000f0a <__register_exitproc+0xa6>
 8000eaa:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8000eae:	f3af 8000 	nop.w
 8000eb2:	4603      	mov	r3, r0
 8000eb4:	b348      	cbz	r0, 8000f0a <__register_exitproc+0xa6>
 8000eb6:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
 8000eba:	2100      	movs	r1, #0
 8000ebc:	e9c0 2100 	strd	r2, r1, [r0]
 8000ec0:	f04f 0c01 	mov.w	ip, #1
 8000ec4:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
 8000ec8:	460a      	mov	r2, r1
 8000eca:	f8c0 1188 	str.w	r1, [r0, #392]	; 0x188
 8000ece:	f8c0 118c 	str.w	r1, [r0, #396]	; 0x18c
 8000ed2:	2e00      	cmp	r6, #0
 8000ed4:	d0dc      	beq.n	8000e90 <__register_exitproc+0x2c>
 8000ed6:	eb03 0182 	add.w	r1, r3, r2, lsl #2
 8000eda:	2401      	movs	r4, #1
 8000edc:	f8c1 9088 	str.w	r9, [r1, #136]	; 0x88
 8000ee0:	f8d3 0188 	ldr.w	r0, [r3, #392]	; 0x188
 8000ee4:	4094      	lsls	r4, r2
 8000ee6:	4320      	orrs	r0, r4
 8000ee8:	2e02      	cmp	r6, #2
 8000eea:	f8c3 0188 	str.w	r0, [r3, #392]	; 0x188
 8000eee:	f8c1 8108 	str.w	r8, [r1, #264]	; 0x108
 8000ef2:	d1cd      	bne.n	8000e90 <__register_exitproc+0x2c>
 8000ef4:	f8d3 118c 	ldr.w	r1, [r3, #396]	; 0x18c
 8000ef8:	430c      	orrs	r4, r1
 8000efa:	f8c3 418c 	str.w	r4, [r3, #396]	; 0x18c
 8000efe:	e7c7      	b.n	8000e90 <__register_exitproc+0x2c>
 8000f00:	f504 73a6 	add.w	r3, r4, #332	; 0x14c
 8000f04:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
 8000f08:	e7bc      	b.n	8000e84 <__register_exitproc+0x20>
 8000f0a:	6828      	ldr	r0, [r5, #0]
 8000f0c:	f7ff ffa8 	bl	8000e60 <__retarget_lock_release_recursive>
 8000f10:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000f14:	e7c5      	b.n	8000ea2 <__register_exitproc+0x3e>
 8000f16:	bf00      	nop
 8000f18:	20000470 	.word	0x20000470
 8000f1c:	08002670 	.word	0x08002670
 8000f20:	00000000 	.word	0x00000000

08000f24 <BSP_LED_Init>:
  *     @arg LED3
  *     @arg LED5
  *     @arg LED6
  */
void BSP_LED_Init(Led_TypeDef Led)
{
 8000f24:	b570      	push	{r4, r5, r6, lr}
 8000f26:	b08a      	sub	sp, #40	; 0x28
  GPIO_InitTypeDef  GPIO_InitStruct;
  
  /* Enable the GPIO_LED Clock */
  LEDx_GPIO_CLK_ENABLE(Led);
 8000f28:	4604      	mov	r4, r0
 8000f2a:	b190      	cbz	r0, 8000f52 <BSP_LED_Init+0x2e>
 8000f2c:	2801      	cmp	r0, #1
 8000f2e:	d033      	beq.n	8000f98 <BSP_LED_Init+0x74>
 8000f30:	2802      	cmp	r0, #2
 8000f32:	d03e      	beq.n	8000fb2 <BSP_LED_Init+0x8e>
 8000f34:	2803      	cmp	r0, #3
 8000f36:	d118      	bne.n	8000f6a <BSP_LED_Init+0x46>
 8000f38:	2300      	movs	r3, #0
 8000f3a:	9304      	str	r3, [sp, #16]
 8000f3c:	4b23      	ldr	r3, [pc, #140]	; (8000fcc <BSP_LED_Init+0xa8>)
 8000f3e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000f40:	f042 0208 	orr.w	r2, r2, #8
 8000f44:	631a      	str	r2, [r3, #48]	; 0x30
 8000f46:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000f48:	f003 0308 	and.w	r3, r3, #8
 8000f4c:	9304      	str	r3, [sp, #16]
 8000f4e:	9b04      	ldr	r3, [sp, #16]
 8000f50:	e00b      	b.n	8000f6a <BSP_LED_Init+0x46>
 8000f52:	2300      	movs	r3, #0
 8000f54:	9301      	str	r3, [sp, #4]
 8000f56:	4b1d      	ldr	r3, [pc, #116]	; (8000fcc <BSP_LED_Init+0xa8>)
 8000f58:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000f5a:	f042 0208 	orr.w	r2, r2, #8
 8000f5e:	631a      	str	r2, [r3, #48]	; 0x30
 8000f60:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000f62:	f003 0308 	and.w	r3, r3, #8
 8000f66:	9301      	str	r3, [sp, #4]
 8000f68:	9b01      	ldr	r3, [sp, #4]

  /* Configure the GPIO_LED pin */
  GPIO_InitStruct.Pin = GPIO_PIN[Led];
 8000f6a:	4b19      	ldr	r3, [pc, #100]	; (8000fd0 <BSP_LED_Init+0xac>)
 8000f6c:	f833 6014 	ldrh.w	r6, [r3, r4, lsl #1]
 8000f70:	9605      	str	r6, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000f72:	2301      	movs	r3, #1
 8000f74:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8000f76:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
 8000f78:	2302      	movs	r3, #2
 8000f7a:	9308      	str	r3, [sp, #32]
  
  HAL_GPIO_Init(GPIO_PORT[Led], &GPIO_InitStruct);
 8000f7c:	4d15      	ldr	r5, [pc, #84]	; (8000fd4 <BSP_LED_Init+0xb0>)
 8000f7e:	a905      	add	r1, sp, #20
 8000f80:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
 8000f84:	f000 f91c 	bl	80011c0 <HAL_GPIO_Init>
  
  HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_RESET); 
 8000f88:	2200      	movs	r2, #0
 8000f8a:	4631      	mov	r1, r6
 8000f8c:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
 8000f90:	f000 f9f6 	bl	8001380 <HAL_GPIO_WritePin>
}
 8000f94:	b00a      	add	sp, #40	; 0x28
 8000f96:	bd70      	pop	{r4, r5, r6, pc}
  LEDx_GPIO_CLK_ENABLE(Led);
 8000f98:	2300      	movs	r3, #0
 8000f9a:	9302      	str	r3, [sp, #8]
 8000f9c:	4b0b      	ldr	r3, [pc, #44]	; (8000fcc <BSP_LED_Init+0xa8>)
 8000f9e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000fa0:	f042 0208 	orr.w	r2, r2, #8
 8000fa4:	631a      	str	r2, [r3, #48]	; 0x30
 8000fa6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000fa8:	f003 0308 	and.w	r3, r3, #8
 8000fac:	9302      	str	r3, [sp, #8]
 8000fae:	9b02      	ldr	r3, [sp, #8]
 8000fb0:	e7db      	b.n	8000f6a <BSP_LED_Init+0x46>
 8000fb2:	2300      	movs	r3, #0
 8000fb4:	9303      	str	r3, [sp, #12]
 8000fb6:	4b05      	ldr	r3, [pc, #20]	; (8000fcc <BSP_LED_Init+0xa8>)
 8000fb8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000fba:	f042 0208 	orr.w	r2, r2, #8
 8000fbe:	631a      	str	r2, [r3, #48]	; 0x30
 8000fc0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000fc2:	f003 0308 	and.w	r3, r3, #8
 8000fc6:	9303      	str	r3, [sp, #12]
 8000fc8:	9b03      	ldr	r3, [sp, #12]
 8000fca:	e7ce      	b.n	8000f6a <BSP_LED_Init+0x46>
 8000fcc:	40023800 	.word	0x40023800
 8000fd0:	08002674 	.word	0x08002674
 8000fd4:	20000474 	.word	0x20000474

08000fd8 <BSP_LED_On>:
  *     @arg LED3
  *     @arg LED5
  *     @arg LED6  
  */
void BSP_LED_On(Led_TypeDef Led)
{
 8000fd8:	b508      	push	{r3, lr}
  HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_SET); 
 8000fda:	2201      	movs	r2, #1
 8000fdc:	4b04      	ldr	r3, [pc, #16]	; (8000ff0 <BSP_LED_On+0x18>)
 8000fde:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 8000fe2:	4b04      	ldr	r3, [pc, #16]	; (8000ff4 <BSP_LED_On+0x1c>)
 8000fe4:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 8000fe8:	f000 f9ca 	bl	8001380 <HAL_GPIO_WritePin>
}
 8000fec:	bd08      	pop	{r3, pc}
 8000fee:	bf00      	nop
 8000ff0:	08002674 	.word	0x08002674
 8000ff4:	20000474 	.word	0x20000474

08000ff8 <BSP_LED_Off>:
  *     @arg LED3
  *     @arg LED5
  *     @arg LED6 
  */
void BSP_LED_Off(Led_TypeDef Led)
{
 8000ff8:	b508      	push	{r3, lr}
  HAL_GPIO_WritePin(GPIO_PORT[Led], GPIO_PIN[Led], GPIO_PIN_RESET); 
 8000ffa:	2200      	movs	r2, #0
 8000ffc:	4b04      	ldr	r3, [pc, #16]	; (8001010 <BSP_LED_Off+0x18>)
 8000ffe:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 8001002:	4b04      	ldr	r3, [pc, #16]	; (8001014 <BSP_LED_Off+0x1c>)
 8001004:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 8001008:	f000 f9ba 	bl	8001380 <HAL_GPIO_WritePin>
}
 800100c:	bd08      	pop	{r3, pc}
 800100e:	bf00      	nop
 8001010:	08002674 	.word	0x08002674
 8001014:	20000474 	.word	0x20000474

08001018 <BSP_LED_Toggle>:
  *     @arg LED3
  *     @arg LED5
  *     @arg LED6  
  */
void BSP_LED_Toggle(Led_TypeDef Led)
{
 8001018:	b508      	push	{r3, lr}
  HAL_GPIO_TogglePin(GPIO_PORT[Led], GPIO_PIN[Led]);
 800101a:	4b04      	ldr	r3, [pc, #16]	; (800102c <BSP_LED_Toggle+0x14>)
 800101c:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 8001020:	4b03      	ldr	r3, [pc, #12]	; (8001030 <BSP_LED_Toggle+0x18>)
 8001022:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 8001026:	f000 f9b1 	bl	800138c <HAL_GPIO_TogglePin>
}
 800102a:	bd08      	pop	{r3, pc}
 800102c:	08002674 	.word	0x08002674
 8001030:	20000474 	.word	0x20000474

08001034 <HAL_MspInit>:
__weak void HAL_MspInit(void)
{
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
 8001034:	4770      	bx	lr
	...

08001038 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8001038:	b510      	push	{r4, lr}
 800103a:	4604      	mov	r4, r0
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 800103c:	4b0e      	ldr	r3, [pc, #56]	; (8001078 <HAL_InitTick+0x40>)
 800103e:	7818      	ldrb	r0, [r3, #0]
 8001040:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8001044:	fbb3 f3f0 	udiv	r3, r3, r0
 8001048:	4a0c      	ldr	r2, [pc, #48]	; (800107c <HAL_InitTick+0x44>)
 800104a:	6810      	ldr	r0, [r2, #0]
 800104c:	fbb0 f0f3 	udiv	r0, r0, r3
 8001050:	f000 f8a0 	bl	8001194 <HAL_SYSTICK_Config>
 8001054:	b968      	cbnz	r0, 8001072 <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8001056:	2c0f      	cmp	r4, #15
 8001058:	d901      	bls.n	800105e <HAL_InitTick+0x26>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
    uwTickPrio = TickPriority;
  }
  else
  {
    return HAL_ERROR;
 800105a:	2001      	movs	r0, #1
 800105c:	e00a      	b.n	8001074 <HAL_InitTick+0x3c>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800105e:	2200      	movs	r2, #0
 8001060:	4621      	mov	r1, r4
 8001062:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8001066:	f000 f861 	bl	800112c <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 800106a:	4b05      	ldr	r3, [pc, #20]	; (8001080 <HAL_InitTick+0x48>)
 800106c:	601c      	str	r4, [r3, #0]
  }

  /* Return function status */
  return HAL_OK;
 800106e:	2000      	movs	r0, #0
 8001070:	e000      	b.n	8001074 <HAL_InitTick+0x3c>
    return HAL_ERROR;
 8001072:	2001      	movs	r0, #1
}
 8001074:	bd10      	pop	{r4, pc}
 8001076:	bf00      	nop
 8001078:	20000484 	.word	0x20000484
 800107c:	2000048c 	.word	0x2000048c
 8001080:	20000488 	.word	0x20000488

08001084 <HAL_Init>:
{
 8001084:	b508      	push	{r3, lr}
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8001086:	4b09      	ldr	r3, [pc, #36]	; (80010ac <HAL_Init+0x28>)
 8001088:	681a      	ldr	r2, [r3, #0]
 800108a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800108e:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_DATA_CACHE_ENABLE();
 8001090:	681a      	ldr	r2, [r3, #0]
 8001092:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8001096:	601a      	str	r2, [r3, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8001098:	2003      	movs	r0, #3
 800109a:	f000 f835 	bl	8001108 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 800109e:	200f      	movs	r0, #15
 80010a0:	f7ff ffca 	bl	8001038 <HAL_InitTick>
  HAL_MspInit();
 80010a4:	f7ff ffc6 	bl	8001034 <HAL_MspInit>
}
 80010a8:	2000      	movs	r0, #0
 80010aa:	bd08      	pop	{r3, pc}
 80010ac:	40023c00 	.word	0x40023c00

080010b0 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 80010b0:	4a03      	ldr	r2, [pc, #12]	; (80010c0 <HAL_IncTick+0x10>)
 80010b2:	6811      	ldr	r1, [r2, #0]
 80010b4:	4b03      	ldr	r3, [pc, #12]	; (80010c4 <HAL_IncTick+0x14>)
 80010b6:	781b      	ldrb	r3, [r3, #0]
 80010b8:	440b      	add	r3, r1
 80010ba:	6013      	str	r3, [r2, #0]
}
 80010bc:	4770      	bx	lr
 80010be:	bf00      	nop
 80010c0:	20000924 	.word	0x20000924
 80010c4:	20000484 	.word	0x20000484

080010c8 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80010c8:	4b01      	ldr	r3, [pc, #4]	; (80010d0 <HAL_GetTick+0x8>)
 80010ca:	6818      	ldr	r0, [r3, #0]
}
 80010cc:	4770      	bx	lr
 80010ce:	bf00      	nop
 80010d0:	20000924 	.word	0x20000924

080010d4 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 80010d4:	b538      	push	{r3, r4, r5, lr}
 80010d6:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 80010d8:	f7ff fff6 	bl	80010c8 <HAL_GetTick>
 80010dc:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 80010de:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
 80010e2:	d002      	beq.n	80010ea <HAL_Delay+0x16>
  {
    wait += (uint32_t)(uwTickFreq);
 80010e4:	4b04      	ldr	r3, [pc, #16]	; (80010f8 <HAL_Delay+0x24>)
 80010e6:	781b      	ldrb	r3, [r3, #0]
 80010e8:	441c      	add	r4, r3
  }

  while((HAL_GetTick() - tickstart) < wait)
 80010ea:	f7ff ffed 	bl	80010c8 <HAL_GetTick>
 80010ee:	1b40      	subs	r0, r0, r5
 80010f0:	42a0      	cmp	r0, r4
 80010f2:	d3fa      	bcc.n	80010ea <HAL_Delay+0x16>
  {
  }
}
 80010f4:	bd38      	pop	{r3, r4, r5, pc}
 80010f6:	bf00      	nop
 80010f8:	20000484 	.word	0x20000484

080010fc <HAL_GetREVID>:
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
  return((DBGMCU->IDCODE) >> 16U);
 80010fc:	4b01      	ldr	r3, [pc, #4]	; (8001104 <HAL_GetREVID+0x8>)
 80010fe:	6818      	ldr	r0, [r3, #0]
}
 8001100:	0c00      	lsrs	r0, r0, #16
 8001102:	4770      	bx	lr
 8001104:	e0042000 	.word	0xe0042000

08001108 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001108:	4a07      	ldr	r2, [pc, #28]	; (8001128 <HAL_NVIC_SetPriorityGrouping+0x20>)
 800110a:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800110c:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8001110:	041b      	lsls	r3, r3, #16
 8001112:	0c1b      	lsrs	r3, r3, #16
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8001114:	0200      	lsls	r0, r0, #8
 8001116:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800111a:	4318      	orrs	r0, r3
  reg_value  =  (reg_value                                   |
 800111c:	f040 60bf 	orr.w	r0, r0, #100139008	; 0x5f80000
 8001120:	f440 3000 	orr.w	r0, r0, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 8001124:	60d0      	str	r0, [r2, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 8001126:	4770      	bx	lr
 8001128:	e000ed00 	.word	0xe000ed00

0800112c <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 800112c:	b430      	push	{r4, r5}
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800112e:	4b17      	ldr	r3, [pc, #92]	; (800118c <HAL_NVIC_SetPriority+0x60>)
 8001130:	68db      	ldr	r3, [r3, #12]
 8001132:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001136:	f1c3 0407 	rsb	r4, r3, #7
 800113a:	2c04      	cmp	r4, #4
 800113c:	bf28      	it	cs
 800113e:	2404      	movcs	r4, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001140:	1d1d      	adds	r5, r3, #4
 8001142:	2d06      	cmp	r5, #6
 8001144:	d918      	bls.n	8001178 <HAL_NVIC_SetPriority+0x4c>
 8001146:	3b03      	subs	r3, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001148:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 800114c:	fa05 f404 	lsl.w	r4, r5, r4
 8001150:	ea21 0104 	bic.w	r1, r1, r4
 8001154:	4099      	lsls	r1, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8001156:	fa05 f303 	lsl.w	r3, r5, r3
 800115a:	ea22 0303 	bic.w	r3, r2, r3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800115e:	4319      	orrs	r1, r3
  if ((int32_t)(IRQn) >= 0)
 8001160:	2800      	cmp	r0, #0
 8001162:	db0b      	blt.n	800117c <HAL_NVIC_SetPriority+0x50>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001164:	0109      	lsls	r1, r1, #4
 8001166:	b2c9      	uxtb	r1, r1
 8001168:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 800116c:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8001170:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8001174:	bc30      	pop	{r4, r5}
 8001176:	4770      	bx	lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001178:	2300      	movs	r3, #0
 800117a:	e7e5      	b.n	8001148 <HAL_NVIC_SetPriority+0x1c>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800117c:	f000 000f 	and.w	r0, r0, #15
 8001180:	0109      	lsls	r1, r1, #4
 8001182:	b2c9      	uxtb	r1, r1
 8001184:	4b02      	ldr	r3, [pc, #8]	; (8001190 <HAL_NVIC_SetPriority+0x64>)
 8001186:	5419      	strb	r1, [r3, r0]
 8001188:	e7f4      	b.n	8001174 <HAL_NVIC_SetPriority+0x48>
 800118a:	bf00      	nop
 800118c:	e000ed00 	.word	0xe000ed00
 8001190:	e000ed14 	.word	0xe000ed14

08001194 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8001194:	3801      	subs	r0, #1
 8001196:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 800119a:	d20a      	bcs.n	80011b2 <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800119c:	4b06      	ldr	r3, [pc, #24]	; (80011b8 <HAL_SYSTICK_Config+0x24>)
 800119e:	6058      	str	r0, [r3, #4]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80011a0:	4a06      	ldr	r2, [pc, #24]	; (80011bc <HAL_SYSTICK_Config+0x28>)
 80011a2:	21f0      	movs	r1, #240	; 0xf0
 80011a4:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80011a8:	2000      	movs	r0, #0
 80011aa:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80011ac:	2207      	movs	r2, #7
 80011ae:	601a      	str	r2, [r3, #0]
 80011b0:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 80011b2:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 80011b4:	4770      	bx	lr
 80011b6:	bf00      	nop
 80011b8:	e000e010 	.word	0xe000e010
 80011bc:	e000ed00 	.word	0xe000ed00

080011c0 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 80011c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80011c2:	b083      	sub	sp, #12
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 80011c4:	2300      	movs	r3, #0
 80011c6:	e036      	b.n	8001236 <HAL_GPIO_Init+0x76>
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80011c8:	2207      	movs	r2, #7
 80011ca:	e000      	b.n	80011ce <HAL_GPIO_Init+0xe>
 80011cc:	2200      	movs	r2, #0
 80011ce:	40aa      	lsls	r2, r5
 80011d0:	433a      	orrs	r2, r7
        SYSCFG->EXTICR[position >> 2U] = temp;
 80011d2:	3402      	adds	r4, #2
 80011d4:	4d66      	ldr	r5, [pc, #408]	; (8001370 <HAL_GPIO_Init+0x1b0>)
 80011d6:	f845 2024 	str.w	r2, [r5, r4, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 80011da:	4a66      	ldr	r2, [pc, #408]	; (8001374 <HAL_GPIO_Init+0x1b4>)
 80011dc:	6814      	ldr	r4, [r2, #0]
        temp &= ~((uint32_t)iocurrent);
 80011de:	43f2      	mvns	r2, r6
 80011e0:	ea02 0504 	and.w	r5, r2, r4
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 80011e4:	684f      	ldr	r7, [r1, #4]
 80011e6:	f417 3f80 	tst.w	r7, #65536	; 0x10000
 80011ea:	d001      	beq.n	80011f0 <HAL_GPIO_Init+0x30>
        {
          temp |= iocurrent;
 80011ec:	ea46 0504 	orr.w	r5, r6, r4
        }
        EXTI->IMR = temp;
 80011f0:	4c60      	ldr	r4, [pc, #384]	; (8001374 <HAL_GPIO_Init+0x1b4>)
 80011f2:	6025      	str	r5, [r4, #0]

        temp = EXTI->EMR;
 80011f4:	6864      	ldr	r4, [r4, #4]
        temp &= ~((uint32_t)iocurrent);
 80011f6:	ea02 0504 	and.w	r5, r2, r4
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 80011fa:	684f      	ldr	r7, [r1, #4]
 80011fc:	f417 3f00 	tst.w	r7, #131072	; 0x20000
 8001200:	d001      	beq.n	8001206 <HAL_GPIO_Init+0x46>
        {
          temp |= iocurrent;
 8001202:	ea46 0504 	orr.w	r5, r6, r4
        }
        EXTI->EMR = temp;
 8001206:	4c5b      	ldr	r4, [pc, #364]	; (8001374 <HAL_GPIO_Init+0x1b4>)
 8001208:	6065      	str	r5, [r4, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 800120a:	68a4      	ldr	r4, [r4, #8]
        temp &= ~((uint32_t)iocurrent);
 800120c:	ea02 0504 	and.w	r5, r2, r4
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8001210:	684f      	ldr	r7, [r1, #4]
 8001212:	f417 1f80 	tst.w	r7, #1048576	; 0x100000
 8001216:	d001      	beq.n	800121c <HAL_GPIO_Init+0x5c>
        {
          temp |= iocurrent;
 8001218:	ea46 0504 	orr.w	r5, r6, r4
        }
        EXTI->RTSR = temp;
 800121c:	4c55      	ldr	r4, [pc, #340]	; (8001374 <HAL_GPIO_Init+0x1b4>)
 800121e:	60a5      	str	r5, [r4, #8]

        temp = EXTI->FTSR;
 8001220:	68e4      	ldr	r4, [r4, #12]
        temp &= ~((uint32_t)iocurrent);
 8001222:	4022      	ands	r2, r4
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001224:	684d      	ldr	r5, [r1, #4]
 8001226:	f415 1f00 	tst.w	r5, #2097152	; 0x200000
 800122a:	d001      	beq.n	8001230 <HAL_GPIO_Init+0x70>
        {
          temp |= iocurrent;
 800122c:	ea46 0204 	orr.w	r2, r6, r4
        }
        EXTI->FTSR = temp;
 8001230:	4c50      	ldr	r4, [pc, #320]	; (8001374 <HAL_GPIO_Init+0x1b4>)
 8001232:	60e2      	str	r2, [r4, #12]
  for(position = 0U; position < GPIO_NUMBER; position++)
 8001234:	3301      	adds	r3, #1
 8001236:	2b0f      	cmp	r3, #15
 8001238:	f200 8098 	bhi.w	800136c <HAL_GPIO_Init+0x1ac>
    ioposition = 0x01U << position;
 800123c:	2201      	movs	r2, #1
 800123e:	409a      	lsls	r2, r3
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8001240:	680c      	ldr	r4, [r1, #0]
 8001242:	ea04 0602 	and.w	r6, r4, r2
    if(iocurrent == ioposition)
 8001246:	42b2      	cmp	r2, r6
 8001248:	d1f4      	bne.n	8001234 <HAL_GPIO_Init+0x74>
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800124a:	684c      	ldr	r4, [r1, #4]
 800124c:	1e65      	subs	r5, r4, #1
 800124e:	2d01      	cmp	r5, #1
 8001250:	d903      	bls.n	800125a <HAL_GPIO_Init+0x9a>
 8001252:	2c11      	cmp	r4, #17
 8001254:	d001      	beq.n	800125a <HAL_GPIO_Init+0x9a>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001256:	2c12      	cmp	r4, #18
 8001258:	d112      	bne.n	8001280 <HAL_GPIO_Init+0xc0>
        temp = GPIOx->OSPEEDR; 
 800125a:	6885      	ldr	r5, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 800125c:	005f      	lsls	r7, r3, #1
 800125e:	2403      	movs	r4, #3
 8001260:	40bc      	lsls	r4, r7
 8001262:	ea25 0504 	bic.w	r5, r5, r4
        temp |= (GPIO_Init->Speed << (position * 2U));
 8001266:	68cc      	ldr	r4, [r1, #12]
 8001268:	40bc      	lsls	r4, r7
 800126a:	432c      	orrs	r4, r5
        GPIOx->OSPEEDR = temp;
 800126c:	6084      	str	r4, [r0, #8]
        temp = GPIOx->OTYPER;
 800126e:	6845      	ldr	r5, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8001270:	ea25 0502 	bic.w	r5, r5, r2
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8001274:	684c      	ldr	r4, [r1, #4]
 8001276:	f3c4 1200 	ubfx	r2, r4, #4, #1
 800127a:	409a      	lsls	r2, r3
 800127c:	432a      	orrs	r2, r5
        GPIOx->OTYPER = temp;
 800127e:	6042      	str	r2, [r0, #4]
      temp = GPIOx->PUPDR;
 8001280:	68c4      	ldr	r4, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8001282:	005f      	lsls	r7, r3, #1
 8001284:	2203      	movs	r2, #3
 8001286:	40ba      	lsls	r2, r7
 8001288:	43d2      	mvns	r2, r2
 800128a:	4014      	ands	r4, r2
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 800128c:	688d      	ldr	r5, [r1, #8]
 800128e:	40bd      	lsls	r5, r7
 8001290:	4325      	orrs	r5, r4
      GPIOx->PUPDR = temp;
 8001292:	60c5      	str	r5, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001294:	684c      	ldr	r4, [r1, #4]
 8001296:	2c02      	cmp	r4, #2
 8001298:	d001      	beq.n	800129e <HAL_GPIO_Init+0xde>
 800129a:	2c12      	cmp	r4, #18
 800129c:	d113      	bne.n	80012c6 <HAL_GPIO_Init+0x106>
        temp = GPIOx->AFR[position >> 3U];
 800129e:	08dd      	lsrs	r5, r3, #3
 80012a0:	3508      	adds	r5, #8
 80012a2:	f850 e025 	ldr.w	lr, [r0, r5, lsl #2]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 80012a6:	f003 0407 	and.w	r4, r3, #7
 80012aa:	ea4f 0c84 	mov.w	ip, r4, lsl #2
 80012ae:	240f      	movs	r4, #15
 80012b0:	fa04 f40c 	lsl.w	r4, r4, ip
 80012b4:	ea2e 0e04 	bic.w	lr, lr, r4
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 80012b8:	690c      	ldr	r4, [r1, #16]
 80012ba:	fa04 f40c 	lsl.w	r4, r4, ip
 80012be:	ea44 040e 	orr.w	r4, r4, lr
        GPIOx->AFR[position >> 3U] = temp;
 80012c2:	f840 4025 	str.w	r4, [r0, r5, lsl #2]
      temp = GPIOx->MODER;
 80012c6:	6804      	ldr	r4, [r0, #0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 80012c8:	4022      	ands	r2, r4
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80012ca:	684c      	ldr	r4, [r1, #4]
 80012cc:	f004 0403 	and.w	r4, r4, #3
 80012d0:	40bc      	lsls	r4, r7
 80012d2:	4322      	orrs	r2, r4
      GPIOx->MODER = temp;
 80012d4:	6002      	str	r2, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 80012d6:	684a      	ldr	r2, [r1, #4]
 80012d8:	f012 5f80 	tst.w	r2, #268435456	; 0x10000000
 80012dc:	d0aa      	beq.n	8001234 <HAL_GPIO_Init+0x74>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80012de:	2200      	movs	r2, #0
 80012e0:	9201      	str	r2, [sp, #4]
 80012e2:	4a25      	ldr	r2, [pc, #148]	; (8001378 <HAL_GPIO_Init+0x1b8>)
 80012e4:	6c54      	ldr	r4, [r2, #68]	; 0x44
 80012e6:	f444 4480 	orr.w	r4, r4, #16384	; 0x4000
 80012ea:	6454      	str	r4, [r2, #68]	; 0x44
 80012ec:	6c52      	ldr	r2, [r2, #68]	; 0x44
 80012ee:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 80012f2:	9201      	str	r2, [sp, #4]
 80012f4:	9a01      	ldr	r2, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2U];
 80012f6:	089c      	lsrs	r4, r3, #2
 80012f8:	1ca5      	adds	r5, r4, #2
 80012fa:	4a1d      	ldr	r2, [pc, #116]	; (8001370 <HAL_GPIO_Init+0x1b0>)
 80012fc:	f852 7025 	ldr.w	r7, [r2, r5, lsl #2]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8001300:	f003 0203 	and.w	r2, r3, #3
 8001304:	0095      	lsls	r5, r2, #2
 8001306:	220f      	movs	r2, #15
 8001308:	40aa      	lsls	r2, r5
 800130a:	ea27 0702 	bic.w	r7, r7, r2
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 800130e:	4a1b      	ldr	r2, [pc, #108]	; (800137c <HAL_GPIO_Init+0x1bc>)
 8001310:	4290      	cmp	r0, r2
 8001312:	f43f af5b 	beq.w	80011cc <HAL_GPIO_Init+0xc>
 8001316:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800131a:	4290      	cmp	r0, r2
 800131c:	d01a      	beq.n	8001354 <HAL_GPIO_Init+0x194>
 800131e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001322:	4290      	cmp	r0, r2
 8001324:	d018      	beq.n	8001358 <HAL_GPIO_Init+0x198>
 8001326:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800132a:	4290      	cmp	r0, r2
 800132c:	d016      	beq.n	800135c <HAL_GPIO_Init+0x19c>
 800132e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001332:	4290      	cmp	r0, r2
 8001334:	d014      	beq.n	8001360 <HAL_GPIO_Init+0x1a0>
 8001336:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800133a:	4290      	cmp	r0, r2
 800133c:	d012      	beq.n	8001364 <HAL_GPIO_Init+0x1a4>
 800133e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001342:	4290      	cmp	r0, r2
 8001344:	d010      	beq.n	8001368 <HAL_GPIO_Init+0x1a8>
 8001346:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800134a:	4290      	cmp	r0, r2
 800134c:	f43f af3c 	beq.w	80011c8 <HAL_GPIO_Init+0x8>
 8001350:	2208      	movs	r2, #8
 8001352:	e73c      	b.n	80011ce <HAL_GPIO_Init+0xe>
 8001354:	2201      	movs	r2, #1
 8001356:	e73a      	b.n	80011ce <HAL_GPIO_Init+0xe>
 8001358:	2202      	movs	r2, #2
 800135a:	e738      	b.n	80011ce <HAL_GPIO_Init+0xe>
 800135c:	2203      	movs	r2, #3
 800135e:	e736      	b.n	80011ce <HAL_GPIO_Init+0xe>
 8001360:	2204      	movs	r2, #4
 8001362:	e734      	b.n	80011ce <HAL_GPIO_Init+0xe>
 8001364:	2205      	movs	r2, #5
 8001366:	e732      	b.n	80011ce <HAL_GPIO_Init+0xe>
 8001368:	2206      	movs	r2, #6
 800136a:	e730      	b.n	80011ce <HAL_GPIO_Init+0xe>
      }
    }
  }
}
 800136c:	b003      	add	sp, #12
 800136e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001370:	40013800 	.word	0x40013800
 8001374:	40013c00 	.word	0x40013c00
 8001378:	40023800 	.word	0x40023800
 800137c:	40020000 	.word	0x40020000

08001380 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8001380:	b912      	cbnz	r2, 8001388 <HAL_GPIO_WritePin+0x8>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 8001382:	0409      	lsls	r1, r1, #16
 8001384:	6181      	str	r1, [r0, #24]
  }
}
 8001386:	4770      	bx	lr
    GPIOx->BSRR = GPIO_Pin;
 8001388:	6181      	str	r1, [r0, #24]
 800138a:	4770      	bx	lr

0800138c <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) == GPIO_Pin)
 800138c:	6943      	ldr	r3, [r0, #20]
 800138e:	ea31 0303 	bics.w	r3, r1, r3
 8001392:	d001      	beq.n	8001398 <HAL_GPIO_TogglePin+0xc>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
  }
  else
  {
    GPIOx->BSRR = GPIO_Pin;
 8001394:	6181      	str	r1, [r0, #24]
  }
}
 8001396:	4770      	bx	lr
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
 8001398:	0409      	lsls	r1, r1, #16
 800139a:	6181      	str	r1, [r0, #24]
 800139c:	4770      	bx	lr
	...

080013a0 <HAL_RCC_OscConfig>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80013a0:	b570      	push	{r4, r5, r6, lr}
 80013a2:	b082      	sub	sp, #8
  uint32_t tickstart, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 80013a4:	4604      	mov	r4, r0
 80013a6:	2800      	cmp	r0, #0
 80013a8:	f000 81e1 	beq.w	800176e <HAL_RCC_OscConfig+0x3ce>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80013ac:	6803      	ldr	r3, [r0, #0]
 80013ae:	f013 0f01 	tst.w	r3, #1
 80013b2:	d03b      	beq.n	800142c <HAL_RCC_OscConfig+0x8c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 80013b4:	4ba7      	ldr	r3, [pc, #668]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 80013b6:	689b      	ldr	r3, [r3, #8]
 80013b8:	f003 030c 	and.w	r3, r3, #12
 80013bc:	2b04      	cmp	r3, #4
 80013be:	d02c      	beq.n	800141a <HAL_RCC_OscConfig+0x7a>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80013c0:	4ba4      	ldr	r3, [pc, #656]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 80013c2:	689b      	ldr	r3, [r3, #8]
 80013c4:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 80013c8:	2b08      	cmp	r3, #8
 80013ca:	d021      	beq.n	8001410 <HAL_RCC_OscConfig+0x70>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80013cc:	6863      	ldr	r3, [r4, #4]
 80013ce:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80013d2:	d04f      	beq.n	8001474 <HAL_RCC_OscConfig+0xd4>
 80013d4:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 80013d8:	d052      	beq.n	8001480 <HAL_RCC_OscConfig+0xe0>
 80013da:	4b9e      	ldr	r3, [pc, #632]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 80013dc:	681a      	ldr	r2, [r3, #0]
 80013de:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80013e2:	601a      	str	r2, [r3, #0]
 80013e4:	681a      	ldr	r2, [r3, #0]
 80013e6:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80013ea:	601a      	str	r2, [r3, #0]

      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 80013ec:	6863      	ldr	r3, [r4, #4]
 80013ee:	2b00      	cmp	r3, #0
 80013f0:	d050      	beq.n	8001494 <HAL_RCC_OscConfig+0xf4>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80013f2:	f7ff fe69 	bl	80010c8 <HAL_GetTick>
 80013f6:	4605      	mov	r5, r0

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80013f8:	4b96      	ldr	r3, [pc, #600]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 80013fa:	681b      	ldr	r3, [r3, #0]
 80013fc:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8001400:	d114      	bne.n	800142c <HAL_RCC_OscConfig+0x8c>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8001402:	f7ff fe61 	bl	80010c8 <HAL_GetTick>
 8001406:	1b40      	subs	r0, r0, r5
 8001408:	2864      	cmp	r0, #100	; 0x64
 800140a:	d9f5      	bls.n	80013f8 <HAL_RCC_OscConfig+0x58>
          {
            return HAL_TIMEOUT;
 800140c:	2003      	movs	r0, #3
 800140e:	e1af      	b.n	8001770 <HAL_RCC_OscConfig+0x3d0>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8001410:	4b90      	ldr	r3, [pc, #576]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 8001412:	685b      	ldr	r3, [r3, #4]
 8001414:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 8001418:	d0d8      	beq.n	80013cc <HAL_RCC_OscConfig+0x2c>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800141a:	4b8e      	ldr	r3, [pc, #568]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 800141c:	681b      	ldr	r3, [r3, #0]
 800141e:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8001422:	d003      	beq.n	800142c <HAL_RCC_OscConfig+0x8c>
 8001424:	6863      	ldr	r3, [r4, #4]
 8001426:	2b00      	cmp	r3, #0
 8001428:	f000 81a4 	beq.w	8001774 <HAL_RCC_OscConfig+0x3d4>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800142c:	6823      	ldr	r3, [r4, #0]
 800142e:	f013 0f02 	tst.w	r3, #2
 8001432:	d055      	beq.n	80014e0 <HAL_RCC_OscConfig+0x140>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8001434:	4b87      	ldr	r3, [pc, #540]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 8001436:	689b      	ldr	r3, [r3, #8]
 8001438:	f013 0f0c 	tst.w	r3, #12
 800143c:	d03e      	beq.n	80014bc <HAL_RCC_OscConfig+0x11c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 800143e:	4b85      	ldr	r3, [pc, #532]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 8001440:	689b      	ldr	r3, [r3, #8]
 8001442:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8001446:	2b08      	cmp	r3, #8
 8001448:	d033      	beq.n	80014b2 <HAL_RCC_OscConfig+0x112>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 800144a:	68e3      	ldr	r3, [r4, #12]
 800144c:	2b00      	cmp	r3, #0
 800144e:	d068      	beq.n	8001522 <HAL_RCC_OscConfig+0x182>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8001450:	4b81      	ldr	r3, [pc, #516]	; (8001658 <HAL_RCC_OscConfig+0x2b8>)
 8001452:	2201      	movs	r2, #1
 8001454:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001456:	f7ff fe37 	bl	80010c8 <HAL_GetTick>
 800145a:	4605      	mov	r5, r0

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800145c:	4b7d      	ldr	r3, [pc, #500]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 800145e:	681b      	ldr	r3, [r3, #0]
 8001460:	f013 0f02 	tst.w	r3, #2
 8001464:	d154      	bne.n	8001510 <HAL_RCC_OscConfig+0x170>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8001466:	f7ff fe2f 	bl	80010c8 <HAL_GetTick>
 800146a:	1b40      	subs	r0, r0, r5
 800146c:	2802      	cmp	r0, #2
 800146e:	d9f5      	bls.n	800145c <HAL_RCC_OscConfig+0xbc>
          {
            return HAL_TIMEOUT;
 8001470:	2003      	movs	r0, #3
 8001472:	e17d      	b.n	8001770 <HAL_RCC_OscConfig+0x3d0>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001474:	4a77      	ldr	r2, [pc, #476]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 8001476:	6813      	ldr	r3, [r2, #0]
 8001478:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800147c:	6013      	str	r3, [r2, #0]
 800147e:	e7b5      	b.n	80013ec <HAL_RCC_OscConfig+0x4c>
 8001480:	4b74      	ldr	r3, [pc, #464]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 8001482:	681a      	ldr	r2, [r3, #0]
 8001484:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8001488:	601a      	str	r2, [r3, #0]
 800148a:	681a      	ldr	r2, [r3, #0]
 800148c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8001490:	601a      	str	r2, [r3, #0]
 8001492:	e7ab      	b.n	80013ec <HAL_RCC_OscConfig+0x4c>
        tickstart = HAL_GetTick();
 8001494:	f7ff fe18 	bl	80010c8 <HAL_GetTick>
 8001498:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800149a:	4b6e      	ldr	r3, [pc, #440]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 800149c:	681b      	ldr	r3, [r3, #0]
 800149e:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80014a2:	d0c3      	beq.n	800142c <HAL_RCC_OscConfig+0x8c>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80014a4:	f7ff fe10 	bl	80010c8 <HAL_GetTick>
 80014a8:	1b40      	subs	r0, r0, r5
 80014aa:	2864      	cmp	r0, #100	; 0x64
 80014ac:	d9f5      	bls.n	800149a <HAL_RCC_OscConfig+0xfa>
            return HAL_TIMEOUT;
 80014ae:	2003      	movs	r0, #3
 80014b0:	e15e      	b.n	8001770 <HAL_RCC_OscConfig+0x3d0>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80014b2:	4b68      	ldr	r3, [pc, #416]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 80014b4:	685b      	ldr	r3, [r3, #4]
 80014b6:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 80014ba:	d1c6      	bne.n	800144a <HAL_RCC_OscConfig+0xaa>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80014bc:	4b65      	ldr	r3, [pc, #404]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 80014be:	681b      	ldr	r3, [r3, #0]
 80014c0:	f013 0f02 	tst.w	r3, #2
 80014c4:	d004      	beq.n	80014d0 <HAL_RCC_OscConfig+0x130>
 80014c6:	68e3      	ldr	r3, [r4, #12]
 80014c8:	2b01      	cmp	r3, #1
 80014ca:	d001      	beq.n	80014d0 <HAL_RCC_OscConfig+0x130>
        return HAL_ERROR;
 80014cc:	2001      	movs	r0, #1
 80014ce:	e14f      	b.n	8001770 <HAL_RCC_OscConfig+0x3d0>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80014d0:	4a60      	ldr	r2, [pc, #384]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 80014d2:	6813      	ldr	r3, [r2, #0]
 80014d4:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 80014d8:	6921      	ldr	r1, [r4, #16]
 80014da:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 80014de:	6013      	str	r3, [r2, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80014e0:	6823      	ldr	r3, [r4, #0]
 80014e2:	f013 0f08 	tst.w	r3, #8
 80014e6:	d040      	beq.n	800156a <HAL_RCC_OscConfig+0x1ca>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 80014e8:	6963      	ldr	r3, [r4, #20]
 80014ea:	b363      	cbz	r3, 8001546 <HAL_RCC_OscConfig+0x1a6>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 80014ec:	4b5b      	ldr	r3, [pc, #364]	; (800165c <HAL_RCC_OscConfig+0x2bc>)
 80014ee:	2201      	movs	r2, #1
 80014f0:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80014f2:	f7ff fde9 	bl	80010c8 <HAL_GetTick>
 80014f6:	4605      	mov	r5, r0

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80014f8:	4b56      	ldr	r3, [pc, #344]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 80014fa:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80014fc:	f013 0f02 	tst.w	r3, #2
 8001500:	d133      	bne.n	800156a <HAL_RCC_OscConfig+0x1ca>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001502:	f7ff fde1 	bl	80010c8 <HAL_GetTick>
 8001506:	1b40      	subs	r0, r0, r5
 8001508:	2802      	cmp	r0, #2
 800150a:	d9f5      	bls.n	80014f8 <HAL_RCC_OscConfig+0x158>
        {
          return HAL_TIMEOUT;
 800150c:	2003      	movs	r0, #3
 800150e:	e12f      	b.n	8001770 <HAL_RCC_OscConfig+0x3d0>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001510:	4a50      	ldr	r2, [pc, #320]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 8001512:	6813      	ldr	r3, [r2, #0]
 8001514:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8001518:	6921      	ldr	r1, [r4, #16]
 800151a:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 800151e:	6013      	str	r3, [r2, #0]
 8001520:	e7de      	b.n	80014e0 <HAL_RCC_OscConfig+0x140>
        __HAL_RCC_HSI_DISABLE();
 8001522:	4b4d      	ldr	r3, [pc, #308]	; (8001658 <HAL_RCC_OscConfig+0x2b8>)
 8001524:	2200      	movs	r2, #0
 8001526:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8001528:	f7ff fdce 	bl	80010c8 <HAL_GetTick>
 800152c:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800152e:	4b49      	ldr	r3, [pc, #292]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 8001530:	681b      	ldr	r3, [r3, #0]
 8001532:	f013 0f02 	tst.w	r3, #2
 8001536:	d0d3      	beq.n	80014e0 <HAL_RCC_OscConfig+0x140>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8001538:	f7ff fdc6 	bl	80010c8 <HAL_GetTick>
 800153c:	1b40      	subs	r0, r0, r5
 800153e:	2802      	cmp	r0, #2
 8001540:	d9f5      	bls.n	800152e <HAL_RCC_OscConfig+0x18e>
            return HAL_TIMEOUT;
 8001542:	2003      	movs	r0, #3
 8001544:	e114      	b.n	8001770 <HAL_RCC_OscConfig+0x3d0>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8001546:	4b45      	ldr	r3, [pc, #276]	; (800165c <HAL_RCC_OscConfig+0x2bc>)
 8001548:	2200      	movs	r2, #0
 800154a:	601a      	str	r2, [r3, #0]

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800154c:	f7ff fdbc 	bl	80010c8 <HAL_GetTick>
 8001550:	4605      	mov	r5, r0

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8001552:	4b40      	ldr	r3, [pc, #256]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 8001554:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8001556:	f013 0f02 	tst.w	r3, #2
 800155a:	d006      	beq.n	800156a <HAL_RCC_OscConfig+0x1ca>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800155c:	f7ff fdb4 	bl	80010c8 <HAL_GetTick>
 8001560:	1b40      	subs	r0, r0, r5
 8001562:	2802      	cmp	r0, #2
 8001564:	d9f5      	bls.n	8001552 <HAL_RCC_OscConfig+0x1b2>
        {
          return HAL_TIMEOUT;
 8001566:	2003      	movs	r0, #3
 8001568:	e102      	b.n	8001770 <HAL_RCC_OscConfig+0x3d0>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800156a:	6823      	ldr	r3, [r4, #0]
 800156c:	f013 0f04 	tst.w	r3, #4
 8001570:	d079      	beq.n	8001666 <HAL_RCC_OscConfig+0x2c6>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8001572:	4b38      	ldr	r3, [pc, #224]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 8001574:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001576:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 800157a:	d133      	bne.n	80015e4 <HAL_RCC_OscConfig+0x244>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 800157c:	2300      	movs	r3, #0
 800157e:	9301      	str	r3, [sp, #4]
 8001580:	4b34      	ldr	r3, [pc, #208]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 8001582:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001584:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001588:	641a      	str	r2, [r3, #64]	; 0x40
 800158a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800158c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001590:	9301      	str	r3, [sp, #4]
 8001592:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8001594:	2501      	movs	r5, #1
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8001596:	4b32      	ldr	r3, [pc, #200]	; (8001660 <HAL_RCC_OscConfig+0x2c0>)
 8001598:	681b      	ldr	r3, [r3, #0]
 800159a:	f413 7f80 	tst.w	r3, #256	; 0x100
 800159e:	d023      	beq.n	80015e8 <HAL_RCC_OscConfig+0x248>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80015a0:	68a3      	ldr	r3, [r4, #8]
 80015a2:	2b01      	cmp	r3, #1
 80015a4:	d034      	beq.n	8001610 <HAL_RCC_OscConfig+0x270>
 80015a6:	2b05      	cmp	r3, #5
 80015a8:	d038      	beq.n	800161c <HAL_RCC_OscConfig+0x27c>
 80015aa:	4b2a      	ldr	r3, [pc, #168]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 80015ac:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80015ae:	f022 0201 	bic.w	r2, r2, #1
 80015b2:	671a      	str	r2, [r3, #112]	; 0x70
 80015b4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80015b6:	f022 0204 	bic.w	r2, r2, #4
 80015ba:	671a      	str	r2, [r3, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 80015bc:	68a3      	ldr	r3, [r4, #8]
 80015be:	2b00      	cmp	r3, #0
 80015c0:	d036      	beq.n	8001630 <HAL_RCC_OscConfig+0x290>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80015c2:	f7ff fd81 	bl	80010c8 <HAL_GetTick>
 80015c6:	4606      	mov	r6, r0

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80015c8:	4b22      	ldr	r3, [pc, #136]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 80015ca:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80015cc:	f013 0f02 	tst.w	r3, #2
 80015d0:	d148      	bne.n	8001664 <HAL_RCC_OscConfig+0x2c4>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80015d2:	f7ff fd79 	bl	80010c8 <HAL_GetTick>
 80015d6:	1b80      	subs	r0, r0, r6
 80015d8:	f241 3388 	movw	r3, #5000	; 0x1388
 80015dc:	4298      	cmp	r0, r3
 80015de:	d9f3      	bls.n	80015c8 <HAL_RCC_OscConfig+0x228>
        {
          return HAL_TIMEOUT;
 80015e0:	2003      	movs	r0, #3
 80015e2:	e0c5      	b.n	8001770 <HAL_RCC_OscConfig+0x3d0>
    FlagStatus       pwrclkchanged = RESET;
 80015e4:	2500      	movs	r5, #0
 80015e6:	e7d6      	b.n	8001596 <HAL_RCC_OscConfig+0x1f6>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 80015e8:	4a1d      	ldr	r2, [pc, #116]	; (8001660 <HAL_RCC_OscConfig+0x2c0>)
 80015ea:	6813      	ldr	r3, [r2, #0]
 80015ec:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80015f0:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 80015f2:	f7ff fd69 	bl	80010c8 <HAL_GetTick>
 80015f6:	4606      	mov	r6, r0
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80015f8:	4b19      	ldr	r3, [pc, #100]	; (8001660 <HAL_RCC_OscConfig+0x2c0>)
 80015fa:	681b      	ldr	r3, [r3, #0]
 80015fc:	f413 7f80 	tst.w	r3, #256	; 0x100
 8001600:	d1ce      	bne.n	80015a0 <HAL_RCC_OscConfig+0x200>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8001602:	f7ff fd61 	bl	80010c8 <HAL_GetTick>
 8001606:	1b80      	subs	r0, r0, r6
 8001608:	2802      	cmp	r0, #2
 800160a:	d9f5      	bls.n	80015f8 <HAL_RCC_OscConfig+0x258>
          return HAL_TIMEOUT;
 800160c:	2003      	movs	r0, #3
 800160e:	e0af      	b.n	8001770 <HAL_RCC_OscConfig+0x3d0>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001610:	4a10      	ldr	r2, [pc, #64]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 8001612:	6f13      	ldr	r3, [r2, #112]	; 0x70
 8001614:	f043 0301 	orr.w	r3, r3, #1
 8001618:	6713      	str	r3, [r2, #112]	; 0x70
 800161a:	e7cf      	b.n	80015bc <HAL_RCC_OscConfig+0x21c>
 800161c:	4b0d      	ldr	r3, [pc, #52]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 800161e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8001620:	f042 0204 	orr.w	r2, r2, #4
 8001624:	671a      	str	r2, [r3, #112]	; 0x70
 8001626:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8001628:	f042 0201 	orr.w	r2, r2, #1
 800162c:	671a      	str	r2, [r3, #112]	; 0x70
 800162e:	e7c5      	b.n	80015bc <HAL_RCC_OscConfig+0x21c>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8001630:	f7ff fd4a 	bl	80010c8 <HAL_GetTick>
 8001634:	4606      	mov	r6, r0

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001636:	4b07      	ldr	r3, [pc, #28]	; (8001654 <HAL_RCC_OscConfig+0x2b4>)
 8001638:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800163a:	f013 0f02 	tst.w	r3, #2
 800163e:	d011      	beq.n	8001664 <HAL_RCC_OscConfig+0x2c4>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001640:	f7ff fd42 	bl	80010c8 <HAL_GetTick>
 8001644:	1b80      	subs	r0, r0, r6
 8001646:	f241 3388 	movw	r3, #5000	; 0x1388
 800164a:	4298      	cmp	r0, r3
 800164c:	d9f3      	bls.n	8001636 <HAL_RCC_OscConfig+0x296>
        {
          return HAL_TIMEOUT;
 800164e:	2003      	movs	r0, #3
 8001650:	e08e      	b.n	8001770 <HAL_RCC_OscConfig+0x3d0>
 8001652:	bf00      	nop
 8001654:	40023800 	.word	0x40023800
 8001658:	42470000 	.word	0x42470000
 800165c:	42470e80 	.word	0x42470e80
 8001660:	40007000 	.word	0x40007000
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8001664:	b9ed      	cbnz	r5, 80016a2 <HAL_RCC_OscConfig+0x302>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8001666:	69a3      	ldr	r3, [r4, #24]
 8001668:	2b00      	cmp	r3, #0
 800166a:	f000 8085 	beq.w	8001778 <HAL_RCC_OscConfig+0x3d8>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 800166e:	4a45      	ldr	r2, [pc, #276]	; (8001784 <HAL_RCC_OscConfig+0x3e4>)
 8001670:	6892      	ldr	r2, [r2, #8]
 8001672:	f002 020c 	and.w	r2, r2, #12
 8001676:	2a08      	cmp	r2, #8
 8001678:	d051      	beq.n	800171e <HAL_RCC_OscConfig+0x37e>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800167a:	2b02      	cmp	r3, #2
 800167c:	d017      	beq.n	80016ae <HAL_RCC_OscConfig+0x30e>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800167e:	4b42      	ldr	r3, [pc, #264]	; (8001788 <HAL_RCC_OscConfig+0x3e8>)
 8001680:	2200      	movs	r2, #0
 8001682:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8001684:	f7ff fd20 	bl	80010c8 <HAL_GetTick>
 8001688:	4604      	mov	r4, r0

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800168a:	4b3e      	ldr	r3, [pc, #248]	; (8001784 <HAL_RCC_OscConfig+0x3e4>)
 800168c:	681b      	ldr	r3, [r3, #0]
 800168e:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8001692:	d042      	beq.n	800171a <HAL_RCC_OscConfig+0x37a>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001694:	f7ff fd18 	bl	80010c8 <HAL_GetTick>
 8001698:	1b00      	subs	r0, r0, r4
 800169a:	2802      	cmp	r0, #2
 800169c:	d9f5      	bls.n	800168a <HAL_RCC_OscConfig+0x2ea>
          {
            return HAL_TIMEOUT;
 800169e:	2003      	movs	r0, #3
 80016a0:	e066      	b.n	8001770 <HAL_RCC_OscConfig+0x3d0>
      __HAL_RCC_PWR_CLK_DISABLE();
 80016a2:	4a38      	ldr	r2, [pc, #224]	; (8001784 <HAL_RCC_OscConfig+0x3e4>)
 80016a4:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80016a6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80016aa:	6413      	str	r3, [r2, #64]	; 0x40
 80016ac:	e7db      	b.n	8001666 <HAL_RCC_OscConfig+0x2c6>
        __HAL_RCC_PLL_DISABLE();
 80016ae:	4b36      	ldr	r3, [pc, #216]	; (8001788 <HAL_RCC_OscConfig+0x3e8>)
 80016b0:	2200      	movs	r2, #0
 80016b2:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80016b4:	f7ff fd08 	bl	80010c8 <HAL_GetTick>
 80016b8:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80016ba:	4b32      	ldr	r3, [pc, #200]	; (8001784 <HAL_RCC_OscConfig+0x3e4>)
 80016bc:	681b      	ldr	r3, [r3, #0]
 80016be:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80016c2:	d006      	beq.n	80016d2 <HAL_RCC_OscConfig+0x332>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80016c4:	f7ff fd00 	bl	80010c8 <HAL_GetTick>
 80016c8:	1b40      	subs	r0, r0, r5
 80016ca:	2802      	cmp	r0, #2
 80016cc:	d9f5      	bls.n	80016ba <HAL_RCC_OscConfig+0x31a>
            return HAL_TIMEOUT;
 80016ce:	2003      	movs	r0, #3
 80016d0:	e04e      	b.n	8001770 <HAL_RCC_OscConfig+0x3d0>
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 80016d2:	69e3      	ldr	r3, [r4, #28]
 80016d4:	6a22      	ldr	r2, [r4, #32]
 80016d6:	4313      	orrs	r3, r2
 80016d8:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80016da:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 80016de:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80016e0:	0852      	lsrs	r2, r2, #1
 80016e2:	3a01      	subs	r2, #1
 80016e4:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80016e8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80016ea:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80016ee:	4a25      	ldr	r2, [pc, #148]	; (8001784 <HAL_RCC_OscConfig+0x3e4>)
 80016f0:	6053      	str	r3, [r2, #4]
        __HAL_RCC_PLL_ENABLE();
 80016f2:	4b25      	ldr	r3, [pc, #148]	; (8001788 <HAL_RCC_OscConfig+0x3e8>)
 80016f4:	2201      	movs	r2, #1
 80016f6:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80016f8:	f7ff fce6 	bl	80010c8 <HAL_GetTick>
 80016fc:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80016fe:	4b21      	ldr	r3, [pc, #132]	; (8001784 <HAL_RCC_OscConfig+0x3e4>)
 8001700:	681b      	ldr	r3, [r3, #0]
 8001702:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8001706:	d106      	bne.n	8001716 <HAL_RCC_OscConfig+0x376>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001708:	f7ff fcde 	bl	80010c8 <HAL_GetTick>
 800170c:	1b00      	subs	r0, r0, r4
 800170e:	2802      	cmp	r0, #2
 8001710:	d9f5      	bls.n	80016fe <HAL_RCC_OscConfig+0x35e>
            return HAL_TIMEOUT;
 8001712:	2003      	movs	r0, #3
 8001714:	e02c      	b.n	8001770 <HAL_RCC_OscConfig+0x3d0>
          return HAL_ERROR;
        }
      }
    }
  }
  return HAL_OK;
 8001716:	2000      	movs	r0, #0
 8001718:	e02a      	b.n	8001770 <HAL_RCC_OscConfig+0x3d0>
 800171a:	2000      	movs	r0, #0
 800171c:	e028      	b.n	8001770 <HAL_RCC_OscConfig+0x3d0>
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 800171e:	2b01      	cmp	r3, #1
 8001720:	d02c      	beq.n	800177c <HAL_RCC_OscConfig+0x3dc>
        pll_config = RCC->PLLCFGR;
 8001722:	4b18      	ldr	r3, [pc, #96]	; (8001784 <HAL_RCC_OscConfig+0x3e4>)
 8001724:	685b      	ldr	r3, [r3, #4]
        if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8001726:	f403 0180 	and.w	r1, r3, #4194304	; 0x400000
 800172a:	69e2      	ldr	r2, [r4, #28]
 800172c:	4291      	cmp	r1, r2
 800172e:	d001      	beq.n	8001734 <HAL_RCC_OscConfig+0x394>
          return HAL_ERROR;
 8001730:	2001      	movs	r0, #1
 8001732:	e01d      	b.n	8001770 <HAL_RCC_OscConfig+0x3d0>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 8001734:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 8001738:	6a21      	ldr	r1, [r4, #32]
        if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800173a:	428a      	cmp	r2, r1
 800173c:	d001      	beq.n	8001742 <HAL_RCC_OscConfig+0x3a2>
          return HAL_ERROR;
 800173e:	2001      	movs	r0, #1
 8001740:	e016      	b.n	8001770 <HAL_RCC_OscConfig+0x3d0>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != RCC_OscInitStruct->PLL.PLLN) ||
 8001742:	6a61      	ldr	r1, [r4, #36]	; 0x24
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 8001744:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 8001748:	401a      	ands	r2, r3
 800174a:	428a      	cmp	r2, r1
 800174c:	d001      	beq.n	8001752 <HAL_RCC_OscConfig+0x3b2>
          return HAL_ERROR;
 800174e:	2001      	movs	r0, #1
 8001750:	e00e      	b.n	8001770 <HAL_RCC_OscConfig+0x3d0>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != RCC_OscInitStruct->PLL.PLLP) ||
 8001752:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
 8001756:	6aa1      	ldr	r1, [r4, #40]	; 0x28
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != RCC_OscInitStruct->PLL.PLLN) ||
 8001758:	428a      	cmp	r2, r1
 800175a:	d001      	beq.n	8001760 <HAL_RCC_OscConfig+0x3c0>
          return HAL_ERROR;
 800175c:	2001      	movs	r0, #1
 800175e:	e007      	b.n	8001770 <HAL_RCC_OscConfig+0x3d0>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != RCC_OscInitStruct->PLL.PLLQ))
 8001760:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
 8001764:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != RCC_OscInitStruct->PLL.PLLP) ||
 8001766:	4293      	cmp	r3, r2
 8001768:	d00a      	beq.n	8001780 <HAL_RCC_OscConfig+0x3e0>
          return HAL_ERROR;
 800176a:	2001      	movs	r0, #1
 800176c:	e000      	b.n	8001770 <HAL_RCC_OscConfig+0x3d0>
    return HAL_ERROR;
 800176e:	2001      	movs	r0, #1
}
 8001770:	b002      	add	sp, #8
 8001772:	bd70      	pop	{r4, r5, r6, pc}
        return HAL_ERROR;
 8001774:	2001      	movs	r0, #1
 8001776:	e7fb      	b.n	8001770 <HAL_RCC_OscConfig+0x3d0>
  return HAL_OK;
 8001778:	2000      	movs	r0, #0
 800177a:	e7f9      	b.n	8001770 <HAL_RCC_OscConfig+0x3d0>
        return HAL_ERROR;
 800177c:	2001      	movs	r0, #1
 800177e:	e7f7      	b.n	8001770 <HAL_RCC_OscConfig+0x3d0>
  return HAL_OK;
 8001780:	2000      	movs	r0, #0
 8001782:	e7f5      	b.n	8001770 <HAL_RCC_OscConfig+0x3d0>
 8001784:	40023800 	.word	0x40023800
 8001788:	42470060 	.word	0x42470060

0800178c <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 800178c:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8001790:	4b31      	ldr	r3, [pc, #196]	; (8001858 <HAL_RCC_GetSysClockFreq+0xcc>)
 8001792:	689b      	ldr	r3, [r3, #8]
 8001794:	f003 030c 	and.w	r3, r3, #12
 8001798:	2b04      	cmp	r3, #4
 800179a:	d05a      	beq.n	8001852 <HAL_RCC_GetSysClockFreq+0xc6>
 800179c:	2b08      	cmp	r3, #8
 800179e:	d002      	beq.n	80017a6 <HAL_RCC_GetSysClockFreq+0x1a>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 80017a0:	482e      	ldr	r0, [pc, #184]	; (800185c <HAL_RCC_GetSysClockFreq+0xd0>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 80017a2:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80017a6:	4b2c      	ldr	r3, [pc, #176]	; (8001858 <HAL_RCC_GetSysClockFreq+0xcc>)
 80017a8:	685a      	ldr	r2, [r3, #4]
 80017aa:	f002 023f 	and.w	r2, r2, #63	; 0x3f
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 80017ae:	685b      	ldr	r3, [r3, #4]
 80017b0:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 80017b4:	d02a      	beq.n	800180c <HAL_RCC_GetSysClockFreq+0x80>
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80017b6:	4b28      	ldr	r3, [pc, #160]	; (8001858 <HAL_RCC_GetSysClockFreq+0xcc>)
 80017b8:	685b      	ldr	r3, [r3, #4]
 80017ba:	f3c3 1388 	ubfx	r3, r3, #6, #9
 80017be:	461e      	mov	r6, r3
 80017c0:	2700      	movs	r7, #0
 80017c2:	015c      	lsls	r4, r3, #5
 80017c4:	2500      	movs	r5, #0
 80017c6:	1ae4      	subs	r4, r4, r3
 80017c8:	eb65 0507 	sbc.w	r5, r5, r7
 80017cc:	01a9      	lsls	r1, r5, #6
 80017ce:	ea41 6194 	orr.w	r1, r1, r4, lsr #26
 80017d2:	01a0      	lsls	r0, r4, #6
 80017d4:	1b00      	subs	r0, r0, r4
 80017d6:	eb61 0105 	sbc.w	r1, r1, r5
 80017da:	00cb      	lsls	r3, r1, #3
 80017dc:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 80017e0:	00c4      	lsls	r4, r0, #3
 80017e2:	19a0      	adds	r0, r4, r6
 80017e4:	eb43 0107 	adc.w	r1, r3, r7
 80017e8:	024b      	lsls	r3, r1, #9
 80017ea:	ea43 53d0 	orr.w	r3, r3, r0, lsr #23
 80017ee:	0244      	lsls	r4, r0, #9
 80017f0:	4620      	mov	r0, r4
 80017f2:	4619      	mov	r1, r3
 80017f4:	2300      	movs	r3, #0
 80017f6:	f7fe fd71 	bl	80002dc <__aeabi_uldivmod>
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 80017fa:	4b17      	ldr	r3, [pc, #92]	; (8001858 <HAL_RCC_GetSysClockFreq+0xcc>)
 80017fc:	685b      	ldr	r3, [r3, #4]
 80017fe:	f3c3 4301 	ubfx	r3, r3, #16, #2
 8001802:	3301      	adds	r3, #1
 8001804:	005b      	lsls	r3, r3, #1
      sysclockfreq = pllvco/pllp;
 8001806:	fbb0 f0f3 	udiv	r0, r0, r3
      break;
 800180a:	e7ca      	b.n	80017a2 <HAL_RCC_GetSysClockFreq+0x16>
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800180c:	4b12      	ldr	r3, [pc, #72]	; (8001858 <HAL_RCC_GetSysClockFreq+0xcc>)
 800180e:	685b      	ldr	r3, [r3, #4]
 8001810:	f3c3 1388 	ubfx	r3, r3, #6, #9
 8001814:	461e      	mov	r6, r3
 8001816:	2700      	movs	r7, #0
 8001818:	015c      	lsls	r4, r3, #5
 800181a:	2500      	movs	r5, #0
 800181c:	1ae4      	subs	r4, r4, r3
 800181e:	eb65 0507 	sbc.w	r5, r5, r7
 8001822:	01a9      	lsls	r1, r5, #6
 8001824:	ea41 6194 	orr.w	r1, r1, r4, lsr #26
 8001828:	01a0      	lsls	r0, r4, #6
 800182a:	1b00      	subs	r0, r0, r4
 800182c:	eb61 0105 	sbc.w	r1, r1, r5
 8001830:	00cb      	lsls	r3, r1, #3
 8001832:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 8001836:	00c4      	lsls	r4, r0, #3
 8001838:	19a0      	adds	r0, r4, r6
 800183a:	eb43 0107 	adc.w	r1, r3, r7
 800183e:	028b      	lsls	r3, r1, #10
 8001840:	ea43 5390 	orr.w	r3, r3, r0, lsr #22
 8001844:	0284      	lsls	r4, r0, #10
 8001846:	4620      	mov	r0, r4
 8001848:	4619      	mov	r1, r3
 800184a:	2300      	movs	r3, #0
 800184c:	f7fe fd46 	bl	80002dc <__aeabi_uldivmod>
 8001850:	e7d3      	b.n	80017fa <HAL_RCC_GetSysClockFreq+0x6e>
      sysclockfreq = HSE_VALUE;
 8001852:	4803      	ldr	r0, [pc, #12]	; (8001860 <HAL_RCC_GetSysClockFreq+0xd4>)
  return sysclockfreq;
 8001854:	e7a5      	b.n	80017a2 <HAL_RCC_GetSysClockFreq+0x16>
 8001856:	bf00      	nop
 8001858:	40023800 	.word	0x40023800
 800185c:	00f42400 	.word	0x00f42400
 8001860:	007a1200 	.word	0x007a1200

08001864 <HAL_RCC_ClockConfig>:
{
 8001864:	b570      	push	{r4, r5, r6, lr}
 8001866:	460d      	mov	r5, r1
  if(RCC_ClkInitStruct == NULL)
 8001868:	4604      	mov	r4, r0
 800186a:	2800      	cmp	r0, #0
 800186c:	f000 809b 	beq.w	80019a6 <HAL_RCC_ClockConfig+0x142>
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8001870:	4b4f      	ldr	r3, [pc, #316]	; (80019b0 <HAL_RCC_ClockConfig+0x14c>)
 8001872:	681b      	ldr	r3, [r3, #0]
 8001874:	f003 030f 	and.w	r3, r3, #15
 8001878:	428b      	cmp	r3, r1
 800187a:	d209      	bcs.n	8001890 <HAL_RCC_ClockConfig+0x2c>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800187c:	b2cb      	uxtb	r3, r1
 800187e:	4a4c      	ldr	r2, [pc, #304]	; (80019b0 <HAL_RCC_ClockConfig+0x14c>)
 8001880:	7013      	strb	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8001882:	6813      	ldr	r3, [r2, #0]
 8001884:	f003 030f 	and.w	r3, r3, #15
 8001888:	428b      	cmp	r3, r1
 800188a:	d001      	beq.n	8001890 <HAL_RCC_ClockConfig+0x2c>
      return HAL_ERROR;
 800188c:	2001      	movs	r0, #1
 800188e:	e08b      	b.n	80019a8 <HAL_RCC_ClockConfig+0x144>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8001890:	6823      	ldr	r3, [r4, #0]
 8001892:	f013 0f02 	tst.w	r3, #2
 8001896:	d017      	beq.n	80018c8 <HAL_RCC_ClockConfig+0x64>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001898:	f013 0f04 	tst.w	r3, #4
 800189c:	d004      	beq.n	80018a8 <HAL_RCC_ClockConfig+0x44>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 800189e:	4a45      	ldr	r2, [pc, #276]	; (80019b4 <HAL_RCC_ClockConfig+0x150>)
 80018a0:	6893      	ldr	r3, [r2, #8]
 80018a2:	f443 53e0 	orr.w	r3, r3, #7168	; 0x1c00
 80018a6:	6093      	str	r3, [r2, #8]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80018a8:	6823      	ldr	r3, [r4, #0]
 80018aa:	f013 0f08 	tst.w	r3, #8
 80018ae:	d004      	beq.n	80018ba <HAL_RCC_ClockConfig+0x56>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 80018b0:	4a40      	ldr	r2, [pc, #256]	; (80019b4 <HAL_RCC_ClockConfig+0x150>)
 80018b2:	6893      	ldr	r3, [r2, #8]
 80018b4:	f443 4360 	orr.w	r3, r3, #57344	; 0xe000
 80018b8:	6093      	str	r3, [r2, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80018ba:	4a3e      	ldr	r2, [pc, #248]	; (80019b4 <HAL_RCC_ClockConfig+0x150>)
 80018bc:	6893      	ldr	r3, [r2, #8]
 80018be:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80018c2:	68a1      	ldr	r1, [r4, #8]
 80018c4:	430b      	orrs	r3, r1
 80018c6:	6093      	str	r3, [r2, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80018c8:	6823      	ldr	r3, [r4, #0]
 80018ca:	f013 0f01 	tst.w	r3, #1
 80018ce:	d032      	beq.n	8001936 <HAL_RCC_ClockConfig+0xd2>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80018d0:	6863      	ldr	r3, [r4, #4]
 80018d2:	2b01      	cmp	r3, #1
 80018d4:	d021      	beq.n	800191a <HAL_RCC_ClockConfig+0xb6>
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 80018d6:	1e9a      	subs	r2, r3, #2
 80018d8:	2a01      	cmp	r2, #1
 80018da:	d925      	bls.n	8001928 <HAL_RCC_ClockConfig+0xc4>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80018dc:	4a35      	ldr	r2, [pc, #212]	; (80019b4 <HAL_RCC_ClockConfig+0x150>)
 80018de:	6812      	ldr	r2, [r2, #0]
 80018e0:	f012 0f02 	tst.w	r2, #2
 80018e4:	d061      	beq.n	80019aa <HAL_RCC_ClockConfig+0x146>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80018e6:	4933      	ldr	r1, [pc, #204]	; (80019b4 <HAL_RCC_ClockConfig+0x150>)
 80018e8:	688a      	ldr	r2, [r1, #8]
 80018ea:	f022 0203 	bic.w	r2, r2, #3
 80018ee:	4313      	orrs	r3, r2
 80018f0:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 80018f2:	f7ff fbe9 	bl	80010c8 <HAL_GetTick>
 80018f6:	4606      	mov	r6, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80018f8:	4b2e      	ldr	r3, [pc, #184]	; (80019b4 <HAL_RCC_ClockConfig+0x150>)
 80018fa:	689b      	ldr	r3, [r3, #8]
 80018fc:	f003 030c 	and.w	r3, r3, #12
 8001900:	6862      	ldr	r2, [r4, #4]
 8001902:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8001906:	d016      	beq.n	8001936 <HAL_RCC_ClockConfig+0xd2>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001908:	f7ff fbde 	bl	80010c8 <HAL_GetTick>
 800190c:	1b80      	subs	r0, r0, r6
 800190e:	f241 3388 	movw	r3, #5000	; 0x1388
 8001912:	4298      	cmp	r0, r3
 8001914:	d9f0      	bls.n	80018f8 <HAL_RCC_ClockConfig+0x94>
        return HAL_TIMEOUT;
 8001916:	2003      	movs	r0, #3
 8001918:	e046      	b.n	80019a8 <HAL_RCC_ClockConfig+0x144>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800191a:	4a26      	ldr	r2, [pc, #152]	; (80019b4 <HAL_RCC_ClockConfig+0x150>)
 800191c:	6812      	ldr	r2, [r2, #0]
 800191e:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8001922:	d1e0      	bne.n	80018e6 <HAL_RCC_ClockConfig+0x82>
        return HAL_ERROR;
 8001924:	2001      	movs	r0, #1
 8001926:	e03f      	b.n	80019a8 <HAL_RCC_ClockConfig+0x144>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001928:	4a22      	ldr	r2, [pc, #136]	; (80019b4 <HAL_RCC_ClockConfig+0x150>)
 800192a:	6812      	ldr	r2, [r2, #0]
 800192c:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 8001930:	d1d9      	bne.n	80018e6 <HAL_RCC_ClockConfig+0x82>
        return HAL_ERROR;
 8001932:	2001      	movs	r0, #1
 8001934:	e038      	b.n	80019a8 <HAL_RCC_ClockConfig+0x144>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8001936:	4b1e      	ldr	r3, [pc, #120]	; (80019b0 <HAL_RCC_ClockConfig+0x14c>)
 8001938:	681b      	ldr	r3, [r3, #0]
 800193a:	f003 030f 	and.w	r3, r3, #15
 800193e:	42ab      	cmp	r3, r5
 8001940:	d909      	bls.n	8001956 <HAL_RCC_ClockConfig+0xf2>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001942:	b2ea      	uxtb	r2, r5
 8001944:	4b1a      	ldr	r3, [pc, #104]	; (80019b0 <HAL_RCC_ClockConfig+0x14c>)
 8001946:	701a      	strb	r2, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8001948:	681b      	ldr	r3, [r3, #0]
 800194a:	f003 030f 	and.w	r3, r3, #15
 800194e:	42ab      	cmp	r3, r5
 8001950:	d001      	beq.n	8001956 <HAL_RCC_ClockConfig+0xf2>
      return HAL_ERROR;
 8001952:	2001      	movs	r0, #1
 8001954:	e028      	b.n	80019a8 <HAL_RCC_ClockConfig+0x144>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001956:	6823      	ldr	r3, [r4, #0]
 8001958:	f013 0f04 	tst.w	r3, #4
 800195c:	d006      	beq.n	800196c <HAL_RCC_ClockConfig+0x108>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800195e:	4a15      	ldr	r2, [pc, #84]	; (80019b4 <HAL_RCC_ClockConfig+0x150>)
 8001960:	6893      	ldr	r3, [r2, #8]
 8001962:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 8001966:	68e1      	ldr	r1, [r4, #12]
 8001968:	430b      	orrs	r3, r1
 800196a:	6093      	str	r3, [r2, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800196c:	6823      	ldr	r3, [r4, #0]
 800196e:	f013 0f08 	tst.w	r3, #8
 8001972:	d007      	beq.n	8001984 <HAL_RCC_ClockConfig+0x120>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8001974:	4a0f      	ldr	r2, [pc, #60]	; (80019b4 <HAL_RCC_ClockConfig+0x150>)
 8001976:	6893      	ldr	r3, [r2, #8]
 8001978:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 800197c:	6921      	ldr	r1, [r4, #16]
 800197e:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8001982:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8001984:	f7ff ff02 	bl	800178c <HAL_RCC_GetSysClockFreq>
 8001988:	4b0a      	ldr	r3, [pc, #40]	; (80019b4 <HAL_RCC_ClockConfig+0x150>)
 800198a:	689b      	ldr	r3, [r3, #8]
 800198c:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8001990:	4a09      	ldr	r2, [pc, #36]	; (80019b8 <HAL_RCC_ClockConfig+0x154>)
 8001992:	5cd3      	ldrb	r3, [r2, r3]
 8001994:	40d8      	lsrs	r0, r3
 8001996:	4b09      	ldr	r3, [pc, #36]	; (80019bc <HAL_RCC_ClockConfig+0x158>)
 8001998:	6018      	str	r0, [r3, #0]
  HAL_InitTick (uwTickPrio);
 800199a:	4b09      	ldr	r3, [pc, #36]	; (80019c0 <HAL_RCC_ClockConfig+0x15c>)
 800199c:	6818      	ldr	r0, [r3, #0]
 800199e:	f7ff fb4b 	bl	8001038 <HAL_InitTick>
  return HAL_OK;
 80019a2:	2000      	movs	r0, #0
 80019a4:	e000      	b.n	80019a8 <HAL_RCC_ClockConfig+0x144>
    return HAL_ERROR;
 80019a6:	2001      	movs	r0, #1
}
 80019a8:	bd70      	pop	{r4, r5, r6, pc}
        return HAL_ERROR;
 80019aa:	2001      	movs	r0, #1
 80019ac:	e7fc      	b.n	80019a8 <HAL_RCC_ClockConfig+0x144>
 80019ae:	bf00      	nop
 80019b0:	40023c00 	.word	0x40023c00
 80019b4:	40023800 	.word	0x40023800
 80019b8:	0800267c 	.word	0x0800267c
 80019bc:	2000048c 	.word	0x2000048c
 80019c0:	20000488 	.word	0x20000488

080019c4 <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 80019c4:	4b01      	ldr	r3, [pc, #4]	; (80019cc <HAL_RCC_GetHCLKFreq+0x8>)
 80019c6:	6818      	ldr	r0, [r3, #0]
 80019c8:	4770      	bx	lr
 80019ca:	bf00      	nop
 80019cc:	2000048c 	.word	0x2000048c

080019d0 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 80019d0:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 80019d2:	f7ff fff7 	bl	80019c4 <HAL_RCC_GetHCLKFreq>
 80019d6:	4b04      	ldr	r3, [pc, #16]	; (80019e8 <HAL_RCC_GetPCLK1Freq+0x18>)
 80019d8:	689b      	ldr	r3, [r3, #8]
 80019da:	f3c3 2382 	ubfx	r3, r3, #10, #3
 80019de:	4a03      	ldr	r2, [pc, #12]	; (80019ec <HAL_RCC_GetPCLK1Freq+0x1c>)
 80019e0:	5cd3      	ldrb	r3, [r2, r3]
}
 80019e2:	40d8      	lsrs	r0, r3
 80019e4:	bd08      	pop	{r3, pc}
 80019e6:	bf00      	nop
 80019e8:	40023800 	.word	0x40023800
 80019ec:	0800268c 	.word	0x0800268c

080019f0 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 80019f0:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 80019f2:	f7ff ffe7 	bl	80019c4 <HAL_RCC_GetHCLKFreq>
 80019f6:	4b04      	ldr	r3, [pc, #16]	; (8001a08 <HAL_RCC_GetPCLK2Freq+0x18>)
 80019f8:	689b      	ldr	r3, [r3, #8]
 80019fa:	f3c3 3342 	ubfx	r3, r3, #13, #3
 80019fe:	4a03      	ldr	r2, [pc, #12]	; (8001a0c <HAL_RCC_GetPCLK2Freq+0x1c>)
 8001a00:	5cd3      	ldrb	r3, [r2, r3]
}
 8001a02:	40d8      	lsrs	r0, r3
 8001a04:	bd08      	pop	{r3, pc}
 8001a06:	bf00      	nop
 8001a08:	40023800 	.word	0x40023800
 8001a0c:	0800268c 	.word	0x0800268c

08001a10 <UART_EndRxTransfer>:
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8001a10:	6802      	ldr	r2, [r0, #0]
 8001a12:	68d3      	ldr	r3, [r2, #12]
 8001a14:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 8001a18:	60d3      	str	r3, [r2, #12]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8001a1a:	6802      	ldr	r2, [r0, #0]
 8001a1c:	6953      	ldr	r3, [r2, #20]
 8001a1e:	f023 0301 	bic.w	r3, r3, #1
 8001a22:	6153      	str	r3, [r2, #20]

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 8001a24:	2320      	movs	r3, #32
 8001a26:	f880 303a 	strb.w	r3, [r0, #58]	; 0x3a
}
 8001a2a:	4770      	bx	lr

08001a2c <UART_Transmit_IT>:
static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
{
  uint16_t *tmp;

  /* Check that a Tx process is ongoing */
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 8001a2c:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8001a30:	b2db      	uxtb	r3, r3
 8001a32:	2b21      	cmp	r3, #33	; 0x21
 8001a34:	d12a      	bne.n	8001a8c <UART_Transmit_IT+0x60>
  {
    if (huart->Init.WordLength == UART_WORDLENGTH_9B)
 8001a36:	6883      	ldr	r3, [r0, #8]
 8001a38:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8001a3c:	d016      	beq.n	8001a6c <UART_Transmit_IT+0x40>
        huart->pTxBuffPtr += 1U;
      }
    }
    else
    {
      huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
 8001a3e:	6a03      	ldr	r3, [r0, #32]
 8001a40:	1c5a      	adds	r2, r3, #1
 8001a42:	6202      	str	r2, [r0, #32]
 8001a44:	781a      	ldrb	r2, [r3, #0]
 8001a46:	6803      	ldr	r3, [r0, #0]
 8001a48:	605a      	str	r2, [r3, #4]
    }

    if (--huart->TxXferCount == 0U)
 8001a4a:	8cc3      	ldrh	r3, [r0, #38]	; 0x26
 8001a4c:	3b01      	subs	r3, #1
 8001a4e:	b29b      	uxth	r3, r3
 8001a50:	84c3      	strh	r3, [r0, #38]	; 0x26
 8001a52:	b9eb      	cbnz	r3, 8001a90 <UART_Transmit_IT+0x64>
    {
      /* Disable the UART Transmit Complete Interrupt */
      __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
 8001a54:	6802      	ldr	r2, [r0, #0]
 8001a56:	68d3      	ldr	r3, [r2, #12]
 8001a58:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8001a5c:	60d3      	str	r3, [r2, #12]

      /* Enable the UART Transmit Complete Interrupt */
      __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
 8001a5e:	6802      	ldr	r2, [r0, #0]
 8001a60:	68d3      	ldr	r3, [r2, #12]
 8001a62:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001a66:	60d3      	str	r3, [r2, #12]
    }
    return HAL_OK;
 8001a68:	2000      	movs	r0, #0
 8001a6a:	4770      	bx	lr
      tmp = (uint16_t *) huart->pTxBuffPtr;
 8001a6c:	6a03      	ldr	r3, [r0, #32]
      huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
 8001a6e:	881b      	ldrh	r3, [r3, #0]
 8001a70:	6802      	ldr	r2, [r0, #0]
 8001a72:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8001a76:	6053      	str	r3, [r2, #4]
      if (huart->Init.Parity == UART_PARITY_NONE)
 8001a78:	6903      	ldr	r3, [r0, #16]
 8001a7a:	b91b      	cbnz	r3, 8001a84 <UART_Transmit_IT+0x58>
        huart->pTxBuffPtr += 2U;
 8001a7c:	6a03      	ldr	r3, [r0, #32]
 8001a7e:	3302      	adds	r3, #2
 8001a80:	6203      	str	r3, [r0, #32]
 8001a82:	e7e2      	b.n	8001a4a <UART_Transmit_IT+0x1e>
        huart->pTxBuffPtr += 1U;
 8001a84:	6a03      	ldr	r3, [r0, #32]
 8001a86:	3301      	adds	r3, #1
 8001a88:	6203      	str	r3, [r0, #32]
 8001a8a:	e7de      	b.n	8001a4a <UART_Transmit_IT+0x1e>
  }
  else
  {
    return HAL_BUSY;
 8001a8c:	2002      	movs	r0, #2
 8001a8e:	4770      	bx	lr
    return HAL_OK;
 8001a90:	2000      	movs	r0, #0
  }
}
 8001a92:	4770      	bx	lr

08001a94 <UART_SetConfig>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 8001a94:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
 8001a98:	4604      	mov	r4, r0
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits
     according to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8001a9a:	6802      	ldr	r2, [r0, #0]
 8001a9c:	6913      	ldr	r3, [r2, #16]
 8001a9e:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8001aa2:	68c1      	ldr	r1, [r0, #12]
 8001aa4:	430b      	orrs	r3, r1
 8001aa6:	6113      	str	r3, [r2, #16]
     Set the M bits according to huart->Init.WordLength value
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */

  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8001aa8:	6883      	ldr	r3, [r0, #8]
 8001aaa:	6902      	ldr	r2, [r0, #16]
 8001aac:	4313      	orrs	r3, r2
 8001aae:	6942      	ldr	r2, [r0, #20]
 8001ab0:	4313      	orrs	r3, r2
 8001ab2:	69c2      	ldr	r2, [r0, #28]
 8001ab4:	431a      	orrs	r2, r3
  MODIFY_REG(huart->Instance->CR1,
 8001ab6:	6801      	ldr	r1, [r0, #0]
 8001ab8:	68cb      	ldr	r3, [r1, #12]
 8001aba:	f423 4316 	bic.w	r3, r3, #38400	; 0x9600
 8001abe:	f023 030c 	bic.w	r3, r3, #12
 8001ac2:	4313      	orrs	r3, r2
 8001ac4:	60cb      	str	r3, [r1, #12]
             (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
             tmpreg);

  /*-------------------------- USART CR3 Configuration -----------------------*/
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 8001ac6:	6802      	ldr	r2, [r0, #0]
 8001ac8:	6953      	ldr	r3, [r2, #20]
 8001aca:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8001ace:	6981      	ldr	r1, [r0, #24]
 8001ad0:	430b      	orrs	r3, r1
 8001ad2:	6153      	str	r3, [r2, #20]

  /* Check the Over Sampling */
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8001ad4:	69c3      	ldr	r3, [r0, #28]
 8001ad6:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8001ada:	d03b      	beq.n	8001b54 <UART_SetConfig+0xc0>
    {
      pclk = HAL_RCC_GetPCLK2Freq();
      huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
    }
#elif defined(USART6)
    if ((huart->Instance == USART1) || (huart->Instance == USART6))
 8001adc:	6803      	ldr	r3, [r0, #0]
 8001ade:	4a71      	ldr	r2, [pc, #452]	; (8001ca4 <UART_SetConfig+0x210>)
 8001ae0:	4293      	cmp	r3, r2
 8001ae2:	f000 80ab 	beq.w	8001c3c <UART_SetConfig+0x1a8>
 8001ae6:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001aea:	4293      	cmp	r3, r2
 8001aec:	f000 80a6 	beq.w	8001c3c <UART_SetConfig+0x1a8>
      huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
    }
#endif /* USART6 */
    else
    {
      pclk = HAL_RCC_GetPCLK1Freq();
 8001af0:	f7ff ff6e 	bl	80019d0 <HAL_RCC_GetPCLK1Freq>
      huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 8001af4:	f04f 0900 	mov.w	r9, #0
 8001af8:	1806      	adds	r6, r0, r0
 8001afa:	eb49 0709 	adc.w	r7, r9, r9
 8001afe:	eb16 0b00 	adds.w	fp, r6, r0
 8001b02:	eb47 0c09 	adc.w	ip, r7, r9
 8001b06:	ea4f 03cc 	mov.w	r3, ip, lsl #3
 8001b0a:	ea43 735b 	orr.w	r3, r3, fp, lsr #29
 8001b0e:	ea4f 02cb 	mov.w	r2, fp, lsl #3
 8001b12:	4693      	mov	fp, r2
 8001b14:	469c      	mov	ip, r3
 8001b16:	6863      	ldr	r3, [r4, #4]
 8001b18:	009a      	lsls	r2, r3, #2
 8001b1a:	0f9b      	lsrs	r3, r3, #30
 8001b1c:	eb10 000b 	adds.w	r0, r0, fp
 8001b20:	eb49 010c 	adc.w	r1, r9, ip
 8001b24:	f7fe fbda 	bl	80002dc <__aeabi_uldivmod>
 8001b28:	4d5f      	ldr	r5, [pc, #380]	; (8001ca8 <UART_SetConfig+0x214>)
 8001b2a:	fba5 3200 	umull	r3, r2, r5, r0
 8001b2e:	0951      	lsrs	r1, r2, #5
 8001b30:	2264      	movs	r2, #100	; 0x64
 8001b32:	fb02 0211 	mls	r2, r2, r1, r0
 8001b36:	0113      	lsls	r3, r2, #4
 8001b38:	3332      	adds	r3, #50	; 0x32
 8001b3a:	fba5 2303 	umull	r2, r3, r5, r3
 8001b3e:	095b      	lsrs	r3, r3, #5
 8001b40:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 8001b44:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 8001b48:	f003 030f 	and.w	r3, r3, #15
 8001b4c:	6821      	ldr	r1, [r4, #0]
 8001b4e:	4413      	add	r3, r2
 8001b50:	608b      	str	r3, [r1, #8]
    }
  }
}
 8001b52:	e0a4      	b.n	8001c9e <UART_SetConfig+0x20a>
    if ((huart->Instance == USART1) || (huart->Instance == USART6))
 8001b54:	6803      	ldr	r3, [r0, #0]
 8001b56:	4a53      	ldr	r2, [pc, #332]	; (8001ca4 <UART_SetConfig+0x210>)
 8001b58:	4293      	cmp	r3, r2
 8001b5a:	d039      	beq.n	8001bd0 <UART_SetConfig+0x13c>
 8001b5c:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001b60:	4293      	cmp	r3, r2
 8001b62:	d035      	beq.n	8001bd0 <UART_SetConfig+0x13c>
      pclk = HAL_RCC_GetPCLK1Freq();
 8001b64:	f7ff ff34 	bl	80019d0 <HAL_RCC_GetPCLK1Freq>
      huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
 8001b68:	4683      	mov	fp, r0
 8001b6a:	f04f 0c00 	mov.w	ip, #0
 8001b6e:	1806      	adds	r6, r0, r0
 8001b70:	eb4c 070c 	adc.w	r7, ip, ip
 8001b74:	eb16 0800 	adds.w	r8, r6, r0
 8001b78:	eb47 090c 	adc.w	r9, r7, ip
 8001b7c:	ea4f 03c9 	mov.w	r3, r9, lsl #3
 8001b80:	ea43 7358 	orr.w	r3, r3, r8, lsr #29
 8001b84:	ea4f 02c8 	mov.w	r2, r8, lsl #3
 8001b88:	4690      	mov	r8, r2
 8001b8a:	4699      	mov	r9, r3
 8001b8c:	6862      	ldr	r2, [r4, #4]
 8001b8e:	2100      	movs	r1, #0
 8001b90:	1892      	adds	r2, r2, r2
 8001b92:	eb41 0301 	adc.w	r3, r1, r1
 8001b96:	eb1b 0008 	adds.w	r0, fp, r8
 8001b9a:	eb4c 0109 	adc.w	r1, ip, r9
 8001b9e:	f7fe fb9d 	bl	80002dc <__aeabi_uldivmod>
 8001ba2:	4d41      	ldr	r5, [pc, #260]	; (8001ca8 <UART_SetConfig+0x214>)
 8001ba4:	fba5 3200 	umull	r3, r2, r5, r0
 8001ba8:	0951      	lsrs	r1, r2, #5
 8001baa:	2264      	movs	r2, #100	; 0x64
 8001bac:	fb02 0211 	mls	r2, r2, r1, r0
 8001bb0:	00d3      	lsls	r3, r2, #3
 8001bb2:	3332      	adds	r3, #50	; 0x32
 8001bb4:	fba5 2303 	umull	r2, r3, r5, r3
 8001bb8:	095b      	lsrs	r3, r3, #5
 8001bba:	005a      	lsls	r2, r3, #1
 8001bbc:	f402 72f8 	and.w	r2, r2, #496	; 0x1f0
 8001bc0:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 8001bc4:	f003 0307 	and.w	r3, r3, #7
 8001bc8:	6821      	ldr	r1, [r4, #0]
 8001bca:	4413      	add	r3, r2
 8001bcc:	608b      	str	r3, [r1, #8]
 8001bce:	e066      	b.n	8001c9e <UART_SetConfig+0x20a>
      pclk = HAL_RCC_GetPCLK2Freq();
 8001bd0:	f7ff ff0e 	bl	80019f0 <HAL_RCC_GetPCLK2Freq>
      huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
 8001bd4:	4680      	mov	r8, r0
 8001bd6:	f04f 0900 	mov.w	r9, #0
 8001bda:	1806      	adds	r6, r0, r0
 8001bdc:	eb49 0709 	adc.w	r7, r9, r9
 8001be0:	eb16 0b00 	adds.w	fp, r6, r0
 8001be4:	eb47 0c09 	adc.w	ip, r7, r9
 8001be8:	ea4f 03cc 	mov.w	r3, ip, lsl #3
 8001bec:	ea43 735b 	orr.w	r3, r3, fp, lsr #29
 8001bf0:	ea4f 02cb 	mov.w	r2, fp, lsl #3
 8001bf4:	4693      	mov	fp, r2
 8001bf6:	469c      	mov	ip, r3
 8001bf8:	6862      	ldr	r2, [r4, #4]
 8001bfa:	2100      	movs	r1, #0
 8001bfc:	1892      	adds	r2, r2, r2
 8001bfe:	eb41 0301 	adc.w	r3, r1, r1
 8001c02:	eb18 000b 	adds.w	r0, r8, fp
 8001c06:	eb49 010c 	adc.w	r1, r9, ip
 8001c0a:	f7fe fb67 	bl	80002dc <__aeabi_uldivmod>
 8001c0e:	4d26      	ldr	r5, [pc, #152]	; (8001ca8 <UART_SetConfig+0x214>)
 8001c10:	fba5 3200 	umull	r3, r2, r5, r0
 8001c14:	0951      	lsrs	r1, r2, #5
 8001c16:	2264      	movs	r2, #100	; 0x64
 8001c18:	fb02 0211 	mls	r2, r2, r1, r0
 8001c1c:	00d3      	lsls	r3, r2, #3
 8001c1e:	3332      	adds	r3, #50	; 0x32
 8001c20:	fba5 2303 	umull	r2, r3, r5, r3
 8001c24:	095b      	lsrs	r3, r3, #5
 8001c26:	005a      	lsls	r2, r3, #1
 8001c28:	f402 72f8 	and.w	r2, r2, #496	; 0x1f0
 8001c2c:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 8001c30:	f003 0307 	and.w	r3, r3, #7
 8001c34:	6821      	ldr	r1, [r4, #0]
 8001c36:	4413      	add	r3, r2
 8001c38:	608b      	str	r3, [r1, #8]
 8001c3a:	e030      	b.n	8001c9e <UART_SetConfig+0x20a>
      pclk = HAL_RCC_GetPCLK2Freq();
 8001c3c:	f7ff fed8 	bl	80019f0 <HAL_RCC_GetPCLK2Freq>
      huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 8001c40:	f04f 0900 	mov.w	r9, #0
 8001c44:	1806      	adds	r6, r0, r0
 8001c46:	eb49 0709 	adc.w	r7, r9, r9
 8001c4a:	eb16 0b00 	adds.w	fp, r6, r0
 8001c4e:	eb47 0c09 	adc.w	ip, r7, r9
 8001c52:	ea4f 03cc 	mov.w	r3, ip, lsl #3
 8001c56:	ea43 735b 	orr.w	r3, r3, fp, lsr #29
 8001c5a:	ea4f 02cb 	mov.w	r2, fp, lsl #3
 8001c5e:	4693      	mov	fp, r2
 8001c60:	469c      	mov	ip, r3
 8001c62:	6863      	ldr	r3, [r4, #4]
 8001c64:	009a      	lsls	r2, r3, #2
 8001c66:	0f9b      	lsrs	r3, r3, #30
 8001c68:	eb10 000b 	adds.w	r0, r0, fp
 8001c6c:	eb49 010c 	adc.w	r1, r9, ip
 8001c70:	f7fe fb34 	bl	80002dc <__aeabi_uldivmod>
 8001c74:	4d0c      	ldr	r5, [pc, #48]	; (8001ca8 <UART_SetConfig+0x214>)
 8001c76:	fba5 3200 	umull	r3, r2, r5, r0
 8001c7a:	0951      	lsrs	r1, r2, #5
 8001c7c:	2264      	movs	r2, #100	; 0x64
 8001c7e:	fb02 0211 	mls	r2, r2, r1, r0
 8001c82:	0113      	lsls	r3, r2, #4
 8001c84:	3332      	adds	r3, #50	; 0x32
 8001c86:	fba5 2303 	umull	r2, r3, r5, r3
 8001c8a:	095b      	lsrs	r3, r3, #5
 8001c8c:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 8001c90:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 8001c94:	f003 030f 	and.w	r3, r3, #15
 8001c98:	6821      	ldr	r1, [r4, #0]
 8001c9a:	4413      	add	r3, r2
 8001c9c:	608b      	str	r3, [r1, #8]
}
 8001c9e:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
 8001ca2:	bf00      	nop
 8001ca4:	40011000 	.word	0x40011000
 8001ca8:	51eb851f 	.word	0x51eb851f

08001cac <HAL_UART_MspInit>:
}
 8001cac:	4770      	bx	lr

08001cae <HAL_UART_Init>:
{
 8001cae:	b510      	push	{r4, lr}
  if (huart == NULL)
 8001cb0:	4604      	mov	r4, r0
 8001cb2:	b348      	cbz	r0, 8001d08 <HAL_UART_Init+0x5a>
  if (huart->gState == HAL_UART_STATE_RESET)
 8001cb4:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8001cb8:	b30b      	cbz	r3, 8001cfe <HAL_UART_Init+0x50>
  huart->gState = HAL_UART_STATE_BUSY;
 8001cba:	2324      	movs	r3, #36	; 0x24
 8001cbc:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  __HAL_UART_DISABLE(huart);
 8001cc0:	6822      	ldr	r2, [r4, #0]
 8001cc2:	68d3      	ldr	r3, [r2, #12]
 8001cc4:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8001cc8:	60d3      	str	r3, [r2, #12]
  UART_SetConfig(huart);
 8001cca:	4620      	mov	r0, r4
 8001ccc:	f7ff fee2 	bl	8001a94 <UART_SetConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8001cd0:	6822      	ldr	r2, [r4, #0]
 8001cd2:	6913      	ldr	r3, [r2, #16]
 8001cd4:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8001cd8:	6113      	str	r3, [r2, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8001cda:	6822      	ldr	r2, [r4, #0]
 8001cdc:	6953      	ldr	r3, [r2, #20]
 8001cde:	f023 032a 	bic.w	r3, r3, #42	; 0x2a
 8001ce2:	6153      	str	r3, [r2, #20]
  __HAL_UART_ENABLE(huart);
 8001ce4:	6822      	ldr	r2, [r4, #0]
 8001ce6:	68d3      	ldr	r3, [r2, #12]
 8001ce8:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8001cec:	60d3      	str	r3, [r2, #12]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001cee:	2000      	movs	r0, #0
 8001cf0:	63e0      	str	r0, [r4, #60]	; 0x3c
  huart->gState = HAL_UART_STATE_READY;
 8001cf2:	2320      	movs	r3, #32
 8001cf4:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  huart->RxState = HAL_UART_STATE_READY;
 8001cf8:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a
}
 8001cfc:	bd10      	pop	{r4, pc}
    huart->Lock = HAL_UNLOCKED;
 8001cfe:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
    HAL_UART_MspInit(huart);
 8001d02:	f7ff ffd3 	bl	8001cac <HAL_UART_MspInit>
 8001d06:	e7d8      	b.n	8001cba <HAL_UART_Init+0xc>
    return HAL_ERROR;
 8001d08:	2001      	movs	r0, #1
 8001d0a:	e7f7      	b.n	8001cfc <HAL_UART_Init+0x4e>

08001d0c <HAL_UART_Transmit_IT>:
  if (huart->gState == HAL_UART_STATE_READY)
 8001d0c:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8001d10:	b2db      	uxtb	r3, r3
 8001d12:	2b20      	cmp	r3, #32
 8001d14:	d116      	bne.n	8001d44 <HAL_UART_Transmit_IT+0x38>
    if ((pData == NULL) || (Size == 0U))
 8001d16:	b1b9      	cbz	r1, 8001d48 <HAL_UART_Transmit_IT+0x3c>
 8001d18:	b1c2      	cbz	r2, 8001d4c <HAL_UART_Transmit_IT+0x40>
    __HAL_LOCK(huart);
 8001d1a:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8001d1e:	2b01      	cmp	r3, #1
 8001d20:	d016      	beq.n	8001d50 <HAL_UART_Transmit_IT+0x44>
    huart->pTxBuffPtr = pData;
 8001d22:	6201      	str	r1, [r0, #32]
    huart->TxXferSize = Size;
 8001d24:	8482      	strh	r2, [r0, #36]	; 0x24
    huart->TxXferCount = Size;
 8001d26:	84c2      	strh	r2, [r0, #38]	; 0x26
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001d28:	2300      	movs	r3, #0
 8001d2a:	63c3      	str	r3, [r0, #60]	; 0x3c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8001d2c:	2221      	movs	r2, #33	; 0x21
 8001d2e:	f880 2039 	strb.w	r2, [r0, #57]	; 0x39
    __HAL_UNLOCK(huart);
 8001d32:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
    __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
 8001d36:	6801      	ldr	r1, [r0, #0]
 8001d38:	68ca      	ldr	r2, [r1, #12]
 8001d3a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8001d3e:	60ca      	str	r2, [r1, #12]
    return HAL_OK;
 8001d40:	4618      	mov	r0, r3
 8001d42:	4770      	bx	lr
    return HAL_BUSY;
 8001d44:	2002      	movs	r0, #2
 8001d46:	4770      	bx	lr
      return HAL_ERROR;
 8001d48:	2001      	movs	r0, #1
 8001d4a:	4770      	bx	lr
 8001d4c:	2001      	movs	r0, #1
 8001d4e:	4770      	bx	lr
    __HAL_LOCK(huart);
 8001d50:	2002      	movs	r0, #2
}
 8001d52:	4770      	bx	lr

08001d54 <HAL_UART_TxCpltCallback>:
}
 8001d54:	4770      	bx	lr

08001d56 <UART_EndTransmit_IT>:
{
 8001d56:	b508      	push	{r3, lr}
  __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
 8001d58:	6801      	ldr	r1, [r0, #0]
 8001d5a:	68cb      	ldr	r3, [r1, #12]
 8001d5c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001d60:	60cb      	str	r3, [r1, #12]
  huart->gState = HAL_UART_STATE_READY;
 8001d62:	2320      	movs	r3, #32
 8001d64:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
  HAL_UART_TxCpltCallback(huart);
 8001d68:	f7ff fff4 	bl	8001d54 <HAL_UART_TxCpltCallback>
}
 8001d6c:	2000      	movs	r0, #0
 8001d6e:	bd08      	pop	{r3, pc}

08001d70 <HAL_UART_RxCpltCallback>:
}
 8001d70:	4770      	bx	lr

08001d72 <UART_Receive_IT>:
{
 8001d72:	b508      	push	{r3, lr}
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8001d74:	f890 303a 	ldrb.w	r3, [r0, #58]	; 0x3a
 8001d78:	b2db      	uxtb	r3, r3
 8001d7a:	2b22      	cmp	r3, #34	; 0x22
 8001d7c:	d145      	bne.n	8001e0a <UART_Receive_IT+0x98>
    if (huart->Init.WordLength == UART_WORDLENGTH_9B)
 8001d7e:	6883      	ldr	r3, [r0, #8]
 8001d80:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8001d84:	d00e      	beq.n	8001da4 <UART_Receive_IT+0x32>
      if (huart->Init.Parity == UART_PARITY_NONE)
 8001d86:	6903      	ldr	r3, [r0, #16]
 8001d88:	bb03      	cbnz	r3, 8001dcc <UART_Receive_IT+0x5a>
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
 8001d8a:	6803      	ldr	r3, [r0, #0]
 8001d8c:	685a      	ldr	r2, [r3, #4]
 8001d8e:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001d90:	1c59      	adds	r1, r3, #1
 8001d92:	6281      	str	r1, [r0, #40]	; 0x28
 8001d94:	701a      	strb	r2, [r3, #0]
    if (--huart->RxXferCount == 0U)
 8001d96:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
 8001d98:	3b01      	subs	r3, #1
 8001d9a:	b29b      	uxth	r3, r3
 8001d9c:	85c3      	strh	r3, [r0, #46]	; 0x2e
 8001d9e:	b1f3      	cbz	r3, 8001dde <UART_Receive_IT+0x6c>
    return HAL_OK;
 8001da0:	2000      	movs	r0, #0
 8001da2:	e033      	b.n	8001e0c <UART_Receive_IT+0x9a>
      tmp = (uint16_t *) huart->pRxBuffPtr;
 8001da4:	6a82      	ldr	r2, [r0, #40]	; 0x28
      if (huart->Init.Parity == UART_PARITY_NONE)
 8001da6:	6903      	ldr	r3, [r0, #16]
 8001da8:	b943      	cbnz	r3, 8001dbc <UART_Receive_IT+0x4a>
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 8001daa:	6803      	ldr	r3, [r0, #0]
 8001dac:	685b      	ldr	r3, [r3, #4]
 8001dae:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8001db2:	8013      	strh	r3, [r2, #0]
        huart->pRxBuffPtr += 2U;
 8001db4:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001db6:	3302      	adds	r3, #2
 8001db8:	6283      	str	r3, [r0, #40]	; 0x28
 8001dba:	e7ec      	b.n	8001d96 <UART_Receive_IT+0x24>
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
 8001dbc:	6803      	ldr	r3, [r0, #0]
 8001dbe:	685b      	ldr	r3, [r3, #4]
 8001dc0:	b2db      	uxtb	r3, r3
 8001dc2:	8013      	strh	r3, [r2, #0]
        huart->pRxBuffPtr += 1U;
 8001dc4:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001dc6:	3301      	adds	r3, #1
 8001dc8:	6283      	str	r3, [r0, #40]	; 0x28
 8001dca:	e7e4      	b.n	8001d96 <UART_Receive_IT+0x24>
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
 8001dcc:	6803      	ldr	r3, [r0, #0]
 8001dce:	685b      	ldr	r3, [r3, #4]
 8001dd0:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8001dd2:	1c51      	adds	r1, r2, #1
 8001dd4:	6281      	str	r1, [r0, #40]	; 0x28
 8001dd6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8001dda:	7013      	strb	r3, [r2, #0]
 8001ddc:	e7db      	b.n	8001d96 <UART_Receive_IT+0x24>
      __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 8001dde:	6802      	ldr	r2, [r0, #0]
 8001de0:	68d3      	ldr	r3, [r2, #12]
 8001de2:	f023 0320 	bic.w	r3, r3, #32
 8001de6:	60d3      	str	r3, [r2, #12]
      __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 8001de8:	6802      	ldr	r2, [r0, #0]
 8001dea:	68d3      	ldr	r3, [r2, #12]
 8001dec:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8001df0:	60d3      	str	r3, [r2, #12]
      __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 8001df2:	6802      	ldr	r2, [r0, #0]
 8001df4:	6953      	ldr	r3, [r2, #20]
 8001df6:	f023 0301 	bic.w	r3, r3, #1
 8001dfa:	6153      	str	r3, [r2, #20]
      huart->RxState = HAL_UART_STATE_READY;
 8001dfc:	2320      	movs	r3, #32
 8001dfe:	f880 303a 	strb.w	r3, [r0, #58]	; 0x3a
      HAL_UART_RxCpltCallback(huart);
 8001e02:	f7ff ffb5 	bl	8001d70 <HAL_UART_RxCpltCallback>
      return HAL_OK;
 8001e06:	2000      	movs	r0, #0
 8001e08:	e000      	b.n	8001e0c <UART_Receive_IT+0x9a>
    return HAL_BUSY;
 8001e0a:	2002      	movs	r0, #2
}
 8001e0c:	bd08      	pop	{r3, pc}

08001e0e <HAL_UART_ErrorCallback>:
}
 8001e0e:	4770      	bx	lr

08001e10 <HAL_UART_IRQHandler>:
{
 8001e10:	b510      	push	{r4, lr}
 8001e12:	4604      	mov	r4, r0
  uint32_t isrflags   = READ_REG(huart->Instance->SR);
 8001e14:	6802      	ldr	r2, [r0, #0]
 8001e16:	6813      	ldr	r3, [r2, #0]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 8001e18:	68d1      	ldr	r1, [r2, #12]
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 8001e1a:	6952      	ldr	r2, [r2, #20]
  if (errorflags == RESET)
 8001e1c:	f013 000f 	ands.w	r0, r3, #15
 8001e20:	d105      	bne.n	8001e2e <HAL_UART_IRQHandler+0x1e>
    if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 8001e22:	f013 0f20 	tst.w	r3, #32
 8001e26:	d002      	beq.n	8001e2e <HAL_UART_IRQHandler+0x1e>
 8001e28:	f011 0f20 	tst.w	r1, #32
 8001e2c:	d156      	bne.n	8001edc <HAL_UART_IRQHandler+0xcc>
  if ((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
 8001e2e:	2800      	cmp	r0, #0
 8001e30:	d06a      	beq.n	8001f08 <HAL_UART_IRQHandler+0xf8>
 8001e32:	f012 0201 	ands.w	r2, r2, #1
 8001e36:	d102      	bne.n	8001e3e <HAL_UART_IRQHandler+0x2e>
 8001e38:	f411 7f90 	tst.w	r1, #288	; 0x120
 8001e3c:	d064      	beq.n	8001f08 <HAL_UART_IRQHandler+0xf8>
    if (((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
 8001e3e:	f013 0f01 	tst.w	r3, #1
 8001e42:	d006      	beq.n	8001e52 <HAL_UART_IRQHandler+0x42>
 8001e44:	f411 7f80 	tst.w	r1, #256	; 0x100
 8001e48:	d003      	beq.n	8001e52 <HAL_UART_IRQHandler+0x42>
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 8001e4a:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8001e4c:	f040 0001 	orr.w	r0, r0, #1
 8001e50:	63e0      	str	r0, [r4, #60]	; 0x3c
    if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8001e52:	f013 0f04 	tst.w	r3, #4
 8001e56:	d004      	beq.n	8001e62 <HAL_UART_IRQHandler+0x52>
 8001e58:	b11a      	cbz	r2, 8001e62 <HAL_UART_IRQHandler+0x52>
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 8001e5a:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8001e5c:	f040 0002 	orr.w	r0, r0, #2
 8001e60:	63e0      	str	r0, [r4, #60]	; 0x3c
    if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8001e62:	f013 0f02 	tst.w	r3, #2
 8001e66:	d004      	beq.n	8001e72 <HAL_UART_IRQHandler+0x62>
 8001e68:	b11a      	cbz	r2, 8001e72 <HAL_UART_IRQHandler+0x62>
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 8001e6a:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8001e6c:	f040 0004 	orr.w	r0, r0, #4
 8001e70:	63e0      	str	r0, [r4, #60]	; 0x3c
    if (((isrflags & USART_SR_ORE) != RESET) && (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
 8001e72:	f013 0f08 	tst.w	r3, #8
 8001e76:	d007      	beq.n	8001e88 <HAL_UART_IRQHandler+0x78>
 8001e78:	f011 0f20 	tst.w	r1, #32
 8001e7c:	d100      	bne.n	8001e80 <HAL_UART_IRQHandler+0x70>
 8001e7e:	b11a      	cbz	r2, 8001e88 <HAL_UART_IRQHandler+0x78>
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 8001e80:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8001e82:	f042 0208 	orr.w	r2, r2, #8
 8001e86:	63e2      	str	r2, [r4, #60]	; 0x3c
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8001e88:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8001e8a:	2a00      	cmp	r2, #0
 8001e8c:	d048      	beq.n	8001f20 <HAL_UART_IRQHandler+0x110>
      if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 8001e8e:	f013 0f20 	tst.w	r3, #32
 8001e92:	d002      	beq.n	8001e9a <HAL_UART_IRQHandler+0x8a>
 8001e94:	f011 0f20 	tst.w	r1, #32
 8001e98:	d124      	bne.n	8001ee4 <HAL_UART_IRQHandler+0xd4>
      dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 8001e9a:	6823      	ldr	r3, [r4, #0]
 8001e9c:	695b      	ldr	r3, [r3, #20]
 8001e9e:	f003 0340 	and.w	r3, r3, #64	; 0x40
      if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 8001ea2:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8001ea4:	f012 0f08 	tst.w	r2, #8
 8001ea8:	d100      	bne.n	8001eac <HAL_UART_IRQHandler+0x9c>
 8001eaa:	b33b      	cbz	r3, 8001efc <HAL_UART_IRQHandler+0xec>
        UART_EndRxTransfer(huart);
 8001eac:	4620      	mov	r0, r4
 8001eae:	f7ff fdaf 	bl	8001a10 <UART_EndRxTransfer>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8001eb2:	6823      	ldr	r3, [r4, #0]
 8001eb4:	695a      	ldr	r2, [r3, #20]
 8001eb6:	f012 0f40 	tst.w	r2, #64	; 0x40
 8001eba:	d01b      	beq.n	8001ef4 <HAL_UART_IRQHandler+0xe4>
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8001ebc:	695a      	ldr	r2, [r3, #20]
 8001ebe:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8001ec2:	615a      	str	r2, [r3, #20]
          if (huart->hdmarx != NULL)
 8001ec4:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8001ec6:	b18b      	cbz	r3, 8001eec <HAL_UART_IRQHandler+0xdc>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8001ec8:	4a1a      	ldr	r2, [pc, #104]	; (8001f34 <HAL_UART_IRQHandler+0x124>)
 8001eca:	651a      	str	r2, [r3, #80]	; 0x50
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8001ecc:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8001ece:	f000 f843 	bl	8001f58 <HAL_DMA_Abort_IT>
 8001ed2:	b328      	cbz	r0, 8001f20 <HAL_UART_IRQHandler+0x110>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8001ed4:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8001ed6:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8001ed8:	4798      	blx	r3
 8001eda:	e021      	b.n	8001f20 <HAL_UART_IRQHandler+0x110>
      UART_Receive_IT(huart);
 8001edc:	4620      	mov	r0, r4
 8001ede:	f7ff ff48 	bl	8001d72 <UART_Receive_IT>
      return;
 8001ee2:	e01d      	b.n	8001f20 <HAL_UART_IRQHandler+0x110>
        UART_Receive_IT(huart);
 8001ee4:	4620      	mov	r0, r4
 8001ee6:	f7ff ff44 	bl	8001d72 <UART_Receive_IT>
 8001eea:	e7d6      	b.n	8001e9a <HAL_UART_IRQHandler+0x8a>
            HAL_UART_ErrorCallback(huart);
 8001eec:	4620      	mov	r0, r4
 8001eee:	f7ff ff8e 	bl	8001e0e <HAL_UART_ErrorCallback>
 8001ef2:	e015      	b.n	8001f20 <HAL_UART_IRQHandler+0x110>
          HAL_UART_ErrorCallback(huart);
 8001ef4:	4620      	mov	r0, r4
 8001ef6:	f7ff ff8a 	bl	8001e0e <HAL_UART_ErrorCallback>
 8001efa:	e011      	b.n	8001f20 <HAL_UART_IRQHandler+0x110>
        HAL_UART_ErrorCallback(huart);
 8001efc:	4620      	mov	r0, r4
 8001efe:	f7ff ff86 	bl	8001e0e <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001f02:	2300      	movs	r3, #0
 8001f04:	63e3      	str	r3, [r4, #60]	; 0x3c
 8001f06:	e00b      	b.n	8001f20 <HAL_UART_IRQHandler+0x110>
  if (((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
 8001f08:	f013 0f80 	tst.w	r3, #128	; 0x80
 8001f0c:	d002      	beq.n	8001f14 <HAL_UART_IRQHandler+0x104>
 8001f0e:	f011 0f80 	tst.w	r1, #128	; 0x80
 8001f12:	d106      	bne.n	8001f22 <HAL_UART_IRQHandler+0x112>
  if (((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
 8001f14:	f013 0f40 	tst.w	r3, #64	; 0x40
 8001f18:	d002      	beq.n	8001f20 <HAL_UART_IRQHandler+0x110>
 8001f1a:	f011 0f40 	tst.w	r1, #64	; 0x40
 8001f1e:	d104      	bne.n	8001f2a <HAL_UART_IRQHandler+0x11a>
}
 8001f20:	bd10      	pop	{r4, pc}
    UART_Transmit_IT(huart);
 8001f22:	4620      	mov	r0, r4
 8001f24:	f7ff fd82 	bl	8001a2c <UART_Transmit_IT>
    return;
 8001f28:	e7fa      	b.n	8001f20 <HAL_UART_IRQHandler+0x110>
    UART_EndTransmit_IT(huart);
 8001f2a:	4620      	mov	r0, r4
 8001f2c:	f7ff ff13 	bl	8001d56 <UART_EndTransmit_IT>
    return;
 8001f30:	e7f6      	b.n	8001f20 <HAL_UART_IRQHandler+0x110>
 8001f32:	bf00      	nop
 8001f34:	08001f39 	.word	0x08001f39

08001f38 <UART_DMAAbortOnError>:
{
 8001f38:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8001f3a:	6b80      	ldr	r0, [r0, #56]	; 0x38
  huart->RxXferCount = 0x00U;
 8001f3c:	2300      	movs	r3, #0
 8001f3e:	85c3      	strh	r3, [r0, #46]	; 0x2e
  huart->TxXferCount = 0x00U;
 8001f40:	84c3      	strh	r3, [r0, #38]	; 0x26
  HAL_UART_ErrorCallback(huart);
 8001f42:	f7ff ff64 	bl	8001e0e <HAL_UART_ErrorCallback>
}
 8001f46:	bd08      	pop	{r3, pc}

08001f48 <SystemInit>:

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8001f48:	4b02      	ldr	r3, [pc, #8]	; (8001f54 <SystemInit+0xc>)
 8001f4a:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8001f4e:	609a      	str	r2, [r3, #8]
#endif
}
 8001f50:	4770      	bx	lr
 8001f52:	bf00      	nop
 8001f54:	e000ed00 	.word	0xe000ed00

08001f58 <HAL_DMA_Abort_IT>:
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8001f58:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8001f5c:	b2db      	uxtb	r3, r3
 8001f5e:	2b02      	cmp	r3, #2
 8001f60:	d003      	beq.n	8001f6a <HAL_DMA_Abort_IT+0x12>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8001f62:	2380      	movs	r3, #128	; 0x80
 8001f64:	6543      	str	r3, [r0, #84]	; 0x54
    return HAL_ERROR;
 8001f66:	2001      	movs	r0, #1
 8001f68:	4770      	bx	lr
  }
  else
  {
    /* Set Abort State  */
    hdma->State = HAL_DMA_STATE_ABORT;
 8001f6a:	2305      	movs	r3, #5
 8001f6c:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 8001f70:	6802      	ldr	r2, [r0, #0]
 8001f72:	6813      	ldr	r3, [r2, #0]
 8001f74:	f023 0301 	bic.w	r3, r3, #1
 8001f78:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 8001f7a:	2000      	movs	r0, #0
}
 8001f7c:	4770      	bx	lr

08001f7e <osEE_suspend_all_interrupts>:
(
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb,
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb
)
{
  if (p_ccb->s_isr_all_cnt == 0U) {
 8001f7e:	7f0b      	ldrb	r3, [r1, #28]
 8001f80:	b123      	cbz	r3, 8001f8c <osEE_suspend_all_interrupts+0xe>
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_hal_suspendIRQ();
    p_ccb->prev_s_isr_all_status = flags;
    ++p_ccb->s_isr_all_cnt;
  } else if (p_ccb->s_isr_all_cnt < OSEE_MAX_BYTE) {
 8001f82:	2bff      	cmp	r3, #255	; 0xff
 8001f84:	d009      	beq.n	8001f9a <osEE_suspend_all_interrupts+0x1c>
    ++p_ccb->s_isr_all_cnt;
 8001f86:	3301      	adds	r3, #1
 8001f88:	770b      	strb	r3, [r1, #28]
#error Add ProtectionHook call here once it has been implemented
#else
    osEE_shutdown_os(p_cdb, E_OS_SYS_SUSPEND_NESTING_LIMIT);
#endif /* OSEE_HAS_PROTECTIONHOOK */
  }
}
 8001f8a:	4770      	bx	lr
/* Suspend/Resume Interrupts */
OSEE_STATIC_INLINE FUNC(OsEE_reg, OS_CODE) OSEE_ALWAYS_INLINE
osEE_hal_suspendIRQ ( void )
{
  register OsEE_reg sr;
  OSEE_GET_ISR(sr);
 8001f8c:	f3ef 8210 	mrs	r2, PRIMASK
  OSEE_CLI();
 8001f90:	b672      	cpsid	i
    p_ccb->prev_s_isr_all_status = flags;
 8001f92:	614a      	str	r2, [r1, #20]
    ++p_ccb->s_isr_all_cnt;
 8001f94:	3301      	adds	r3, #1
 8001f96:	770b      	strb	r3, [r1, #28]
 8001f98:	4770      	bx	lr
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST) p_cdb,
  VAR(StatusType, AUTOMATIC)                Error
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
 8001f9a:	6803      	ldr	r3, [r0, #0]

  p_ccb->os_status = OSEE_KERNEL_SHUTDOWN;
 8001f9c:	2203      	movs	r2, #3
 8001f9e:	741a      	strb	r2, [r3, #16]
  /* Used to propagate the error to the ShutdownHook */
  p_ccb->last_error = Error;
 8001fa0:	2219      	movs	r2, #25
 8001fa2:	749a      	strb	r2, [r3, #18]
 8001fa4:	b672      	cpsid	i
 8001fa6:	e7fe      	b.n	8001fa6 <osEE_suspend_all_interrupts+0x28>

08001fa8 <DisableAllInterrupts>:
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
 8001fa8:	4b02      	ldr	r3, [pc, #8]	; (8001fb4 <DisableAllInterrupts+0xc>)
 8001faa:	681b      	ldr	r3, [r3, #0]
 8001fac:	b672      	cpsid	i
  p_ccb->d_isr_all_cnt = 1U;
 8001fae:	2201      	movs	r2, #1
 8001fb0:	779a      	strb	r2, [r3, #30]
}
 8001fb2:	4770      	bx	lr
 8001fb4:	08002510 	.word	0x08002510

08001fb8 <SuspendAllInterrupts>:
FUNC(void, OS_CODE)
  SuspendAllInterrupts
(
  void
)
{
 8001fb8:	b508      	push	{r3, lr}
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
 8001fba:	4802      	ldr	r0, [pc, #8]	; (8001fc4 <SuspendAllInterrupts+0xc>)

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_SuspendAllInterrupts);

  osEE_stack_monitoring(p_cdb);

  osEE_suspend_all_interrupts(p_cdb, p_ccb);
 8001fbc:	6801      	ldr	r1, [r0, #0]
 8001fbe:	f7ff ffde 	bl	8001f7e <osEE_suspend_all_interrupts>

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_SuspendAllInterrupts);

  return;
}
 8001fc2:	bd08      	pop	{r3, pc}
 8001fc4:	08002510 	.word	0x08002510

08001fc8 <ResumeAllInterrupts>:
(
  void
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
 8001fc8:	4b05      	ldr	r3, [pc, #20]	; (8001fe0 <ResumeAllInterrupts+0x18>)
 8001fca:	681a      	ldr	r2, [r3, #0]

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_ResumeAllInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_all_cnt > 0U) {
 8001fcc:	7f13      	ldrb	r3, [r2, #28]
 8001fce:	b133      	cbz	r3, 8001fde <ResumeAllInterrupts+0x16>
    --p_ccb->s_isr_all_cnt;
 8001fd0:	3b01      	subs	r3, #1
 8001fd2:	b2db      	uxtb	r3, r3
 8001fd4:	7713      	strb	r3, [r2, #28]

    if (p_ccb->s_isr_all_cnt == 0U) {
 8001fd6:	b913      	cbnz	r3, 8001fde <ResumeAllInterrupts+0x16>
      osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
 8001fd8:	6953      	ldr	r3, [r2, #20]

OSEE_STATIC_INLINE FUNC(void, OS_CODE) OSEE_ALWAYS_INLINE
osEE_hal_resumeIRQ ( OsEE_reg flags )
{
  OSEE_BARRIER();
  OSEE_SET_ISR(flags);
 8001fda:	f383 8810 	msr	PRIMASK, r3
  }

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ResumeAllInterrupts);

  return;
}
 8001fde:	4770      	bx	lr
 8001fe0:	08002510 	.word	0x08002510

08001fe4 <StartOS>:
FUNC(StatusType, OS_CODE)
  StartOS
(
  VAR(AppModeType, AUTOMATIC) Mode
)
{
 8001fe4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001fe6:	4606      	mov	r6, r0
  CONST(CoreIdType, AUTOMATIC)           curr_core_id = osEE_get_curr_core_id();
  CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_CONST)  p_kdb = osEE_get_kernel();
  CONSTP2VAR(OsEE_KCB, AUTOMATIC, OS_APPL_DATA)   p_kcb = p_kdb->p_kcb;
#endif /* !OSEE_SINGLECORE */
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
 8001fe8:	4b19      	ldr	r3, [pc, #100]	; (8002050 <StartOS+0x6c>)
 8001fea:	681d      	ldr	r5, [r3, #0]
 * an IRQ and from within a task. */
OSEE_STATIC_INLINE FUNC(OsEE_reg, OS_CODE) OSEE_ALWAYS_INLINE
osEE_hal_begin_nested_primitive( void )
{
  OsEE_reg flags = 0U;
  OSEE_GET_IPL(flags);
 8001fec:	f3ef 8411 	mrs	r4, BASEPRI
  flags >>= OSEE_CORTEX_M_PRIO_SH_BITS;
 8001ff0:	0923      	lsrs	r3, r4, #4
  if ( (flags == 0x00U) || (flags > OSEE_ISR2_MAX_HW_PRIO) ) {
 8001ff2:	3b01      	subs	r3, #1
 8001ff4:	2b07      	cmp	r3, #7
 8001ff6:	d902      	bls.n	8001ffe <StartOS+0x1a>
    OSEE_SET_IPL(OSEE_ISR2_MAX_HW_PRIO << OSEE_CORTEX_M_PRIO_SH_BITS);
 8001ff8:	2380      	movs	r3, #128	; 0x80
 8001ffa:	f383 8811 	msr	BASEPRI, r3
  osEE_orti_trace_service_entry(p_ccb, OSServiceId_StartOS);
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  osEE_lock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */

  if (p_ccb->os_status != OSEE_KERNEL_INITIALIZED) {
 8001ffe:	7c2b      	ldrb	r3, [r5, #16]
 8002000:	b133      	cbz	r3, 8002010 <StartOS+0x2c>
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    osEE_unlock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */
    ev = E_OS_ACCESS;
 8002002:	2001      	movs	r0, #1
      osEE_hal_enableIRQ();
    }
#endif /* OSEE_STARTOS_RETURN || OSEE_API_DYNAMIC */
  }

  if (ev != E_OK) {
 8002004:	b118      	cbz	r0, 800200e <StartOS+0x2a>
OSEE_STATIC_INLINE FUNC(void, OS_CODE) OSEE_ALWAYS_INLINE
osEE_hal_end_nested_primitive(
  VAR(OsEE_reg, AUTOMATIC)	flag
)
{
  OSEE_SET_IPL(flag << OSEE_CORTEX_M_PRIO_SH_BITS);
 8002006:	f024 040f 	bic.w	r4, r4, #15
 800200a:	f384 8811 	msr	BASEPRI, r4
    osEE_orti_trace_service_exit(p_ccb, OSServiceId_StartOS);
    osEE_end_primitive(flags);
  }

  return ev;
}
 800200e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
#endif	/* OS_EE_ARCH_CORTEX_M_M4F_FPU */
#endif	/* 0 - [GS]: T.B.C. */
#if	(defined(OSEE_HAS_ORTI)) || (defined(OSEE_HAS_STACK_MONITORING))
    osEE_cortex_m_stack_init();
#endif	/* OSEE_HAS_ORTI || OSEE_HAS_STACK_MONITORING */
    osEE_cortex_m_system_init();
 8002010:	f000 f989 	bl	8002326 <osEE_cortex_m_system_init>
      p_idle_tdb = p_cdb->p_idle_task;
 8002014:	4b0e      	ldr	r3, [pc, #56]	; (8002050 <StartOS+0x6c>)
 8002016:	689f      	ldr	r7, [r3, #8]
    p_ccb->os_status                = OSEE_KERNEL_STARTING;
 8002018:	2301      	movs	r3, #1
 800201a:	742b      	strb	r3, [r5, #16]
    p_ccb->app_mode                 = real_mode;
 800201c:	746e      	strb	r6, [r5, #17]
  StartupHook();
 800201e:	f7fe fb82 	bl	8000726 <StartupHook>
    if (p_ccb->os_status == OSEE_KERNEL_STARTING) {
 8002022:	7c2b      	ldrb	r3, [r5, #16]
 8002024:	b2db      	uxtb	r3, r3
 8002026:	2b01      	cmp	r3, #1
 8002028:	d005      	beq.n	8002036 <StartOS+0x52>
    if (p_ccb->os_status == OSEE_KERNEL_STARTED) {
 800202a:	7c2b      	ldrb	r3, [r5, #16]
 800202c:	b2db      	uxtb	r3, r3
 800202e:	2b02      	cmp	r3, #2
 8002030:	d004      	beq.n	800203c <StartOS+0x58>
  VAR(StatusType, AUTOMATIC)                      ev = E_OK;
 8002032:	2000      	movs	r0, #0
 8002034:	e7e6      	b.n	8002004 <StartOS+0x20>
      p_ccb->os_status = OSEE_KERNEL_STARTED;
 8002036:	2302      	movs	r3, #2
 8002038:	742b      	strb	r3, [r5, #16]
 800203a:	e7f6      	b.n	800202a <StartOS+0x46>
  osEE_idle_task_start
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_idle_tdb
)
{
  osEE_hal_save_ctx_and_ready2stacked(p_idle_tdb, p_idle_tdb->hdb.p_scb,
 800203c:	687a      	ldr	r2, [r7, #4]
 800203e:	4611      	mov	r1, r2
 8002040:	4638      	mov	r0, r7
 8002042:	f7fe faef 	bl	8000624 <osEE_hal_save_ctx_and_ready2stacked>
      osEE_task_end(p_idle_tdb);
 8002046:	4638      	mov	r0, r7
 8002048:	f000 f8b3 	bl	80021b2 <osEE_task_end>
  VAR(StatusType, AUTOMATIC)                      ev = E_OK;
 800204c:	2000      	movs	r0, #0
 800204e:	e7d9      	b.n	8002004 <StartOS+0x20>
 8002050:	08002510 	.word	0x08002510

08002054 <ActivateTask>:
FUNC(StatusType, OS_CODE)
  ActivateTask
(
  VAR(TaskType, AUTOMATIC) TaskID
)
{
 8002054:	b570      	push	{r4, r5, r6, lr}
  return (tid < p_kdb->tdb_array_size);
 8002056:	4b14      	ldr	r3, [pc, #80]	; (80020a8 <ActivateTask+0x54>)
 8002058:	689b      	ldr	r3, [r3, #8]
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
 800205a:	4298      	cmp	r0, r3
 800205c:	d21f      	bcs.n	800209e <ActivateTask+0x4a>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_act = (*p_kdb->p_tdb_ptr_array)[TaskID];
 800205e:	4b12      	ldr	r3, [pc, #72]	; (80020a8 <ActivateTask+0x54>)
 8002060:	685b      	ldr	r3, [r3, #4]
 8002062:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]

    if (p_tdb_act->task_type <= OSEE_TASK_TYPE_EXTENDED) {
 8002066:	7c33      	ldrb	r3, [r6, #16]
 8002068:	2b01      	cmp	r3, #1
 800206a:	d81a      	bhi.n	80020a2 <ActivateTask+0x4e>
  OSEE_GET_IPL(flags);
 800206c:	f3ef 8511 	mrs	r5, BASEPRI
  flags >>= OSEE_CORTEX_M_PRIO_SH_BITS;
 8002070:	092b      	lsrs	r3, r5, #4
  if ( (flags == 0x00U) || (flags > OSEE_ISR2_MAX_HW_PRIO) ) {
 8002072:	3b01      	subs	r3, #1
 8002074:	2b07      	cmp	r3, #7
 8002076:	d902      	bls.n	800207e <ActivateTask+0x2a>
    OSEE_SET_IPL(OSEE_ISR2_MAX_HW_PRIO << OSEE_CORTEX_M_PRIO_SH_BITS);
 8002078:	2380      	movs	r3, #128	; 0x80
 800207a:	f383 8811 	msr	BASEPRI, r3
      CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();

      ev = osEE_task_activated(p_tdb_act);
 800207e:	4630      	mov	r0, r6
 8002080:	f000 f88c 	bl	800219c <osEE_task_activated>

      if (ev == E_OK) {
 8002084:	4604      	mov	r4, r0
 8002086:	b128      	cbz	r0, 8002094 <ActivateTask+0x40>
  OSEE_SET_IPL(flag << OSEE_CORTEX_M_PRIO_SH_BITS);
 8002088:	f025 050f 	bic.w	r5, r5, #15
 800208c:	f385 8811 	msr	BASEPRI, r5
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ActivateTask);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
 8002090:	4620      	mov	r0, r4
 8002092:	bd70      	pop	{r4, r5, r6, pc}
        (void)osEE_scheduler_task_activated(p_kdb, p_tdb_act);
 8002094:	4631      	mov	r1, r6
 8002096:	4804      	ldr	r0, [pc, #16]	; (80020a8 <ActivateTask+0x54>)
 8002098:	f000 f8a8 	bl	80021ec <osEE_scheduler_task_activated>
 800209c:	e7f4      	b.n	8002088 <ActivateTask+0x34>
    ev = E_OS_ID;
 800209e:	2403      	movs	r4, #3
 80020a0:	e7f6      	b.n	8002090 <ActivateTask+0x3c>
      ev = E_OS_ID;
 80020a2:	2403      	movs	r4, #3
 80020a4:	e7f4      	b.n	8002090 <ActivateTask+0x3c>
 80020a6:	bf00      	nop
 80020a8:	0800251c 	.word	0x0800251c

080020ac <TerminateTask>:
FUNC(StatusType, OS_CODE)
  TerminateTask
(
  void
)
{
 80020ac:	b508      	push	{r3, lr}
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK &&
          OSEE_HAS_SERVICE_PROTECTION */
    p_ccb       = p_cdb->p_ccb;
 80020ae:	4b0e      	ldr	r3, [pc, #56]	; (80020e8 <TerminateTask+0x3c>)
 80020b0:	681b      	ldr	r3, [r3, #0]
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
 80020b2:	681a      	ldr	r2, [r3, #0]
#endif /* OSEE_HAS_CHECKS elif (OSEE_HAS_ORTI || OSEE_HAS_STACK_MONITORING) */
  {
    VAR(OsEE_reg, AUTOMATIC) flags;
#if (!defined(OSEE_HAS_SERVICE_PROTECTION))
      /* Silently reset ISR counters if service protection is not configured */
      if (p_ccb->s_isr_all_cnt > 0U) {
 80020b4:	7f19      	ldrb	r1, [r3, #28]
 80020b6:	b121      	cbz	r1, 80020c2 <TerminateTask+0x16>
        p_ccb->s_isr_all_cnt = 0U;
 80020b8:	2100      	movs	r1, #0
 80020ba:	7719      	strb	r1, [r3, #28]
        osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
 80020bc:	6959      	ldr	r1, [r3, #20]
  OSEE_SET_ISR(flags);
 80020be:	f381 8810 	msr	PRIMASK, r1
      }
      if (p_ccb->d_isr_all_cnt > 0U) {
 80020c2:	7f99      	ldrb	r1, [r3, #30]
 80020c4:	b111      	cbz	r1, 80020cc <TerminateTask+0x20>
        p_ccb->d_isr_all_cnt = 0U;
 80020c6:	2100      	movs	r1, #0
 80020c8:	7799      	strb	r1, [r3, #30]
  OSEE_SEI();
 80020ca:	b662      	cpsie	i
  OSEE_GET_IPL(flags);
 80020cc:	f3ef 8311 	mrs	r3, BASEPRI
  flags >>= OSEE_CORTEX_M_PRIO_SH_BITS;
 80020d0:	091b      	lsrs	r3, r3, #4
  if ( (flags == 0x00U) || (flags > OSEE_ISR2_MAX_HW_PRIO) ) {
 80020d2:	3b01      	subs	r3, #1
 80020d4:	2b07      	cmp	r3, #7
 80020d6:	d902      	bls.n	80020de <TerminateTask+0x32>
    OSEE_SET_IPL(OSEE_ISR2_MAX_HW_PRIO << OSEE_CORTEX_M_PRIO_SH_BITS);
 80020d8:	2380      	movs	r3, #128	; 0x80
 80020da:	f383 8811 	msr	BASEPRI, r3
  osEE_hal_terminate_ctx(p_to_term->p_scb, kernel_cb);
 80020de:	4903      	ldr	r1, [pc, #12]	; (80020ec <TerminateTask+0x40>)
 80020e0:	6850      	ldr	r0, [r2, #4]
 80020e2:	f7fe faad 	bl	8000640 <osEE_hal_terminate_ctx>
 80020e6:	bf00      	nop
 80020e8:	08002510 	.word	0x08002510
 80020ec:	08002335 	.word	0x08002335

080020f0 <osEE_scheduler_task_not_terminated>:
static FUNC(void, OS_CODE)
  osEE_scheduler_task_not_terminated
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_to_term
)
{
 80020f0:	b508      	push	{r3, lr}
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)
    p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
 80020f2:	4b0e      	ldr	r3, [pc, #56]	; (800212c <osEE_scheduler_task_not_terminated+0x3c>)
 80020f4:	681b      	ldr	r3, [r3, #0]

  /* Reset ISR Counters */
/* [SWS_Os_00239] If a task returns from the entry function without making a
    TerminateTask() or ChainTask() call and interrupts are still disabled,
    the Operating System module shall enable them. */
  p_ccb->s_isr_os_cnt  = 0U;
 80020f6:	2200      	movs	r2, #0
 80020f8:	775a      	strb	r2, [r3, #29]
  /* I won't re-enable OS Interrupts since I'm going to enter rescheduling
     critical section */
  if (p_ccb->s_isr_all_cnt > 0U) {
 80020fa:	7f1a      	ldrb	r2, [r3, #28]
 80020fc:	b122      	cbz	r2, 8002108 <osEE_scheduler_task_not_terminated+0x18>
    p_ccb->s_isr_all_cnt = 0U;
 80020fe:	2200      	movs	r2, #0
 8002100:	771a      	strb	r2, [r3, #28]
    osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
 8002102:	695a      	ldr	r2, [r3, #20]
  OSEE_SET_ISR(flags);
 8002104:	f382 8810 	msr	PRIMASK, r2
  }
  if (p_ccb->d_isr_all_cnt > 0U) {
 8002108:	7f9a      	ldrb	r2, [r3, #30]
 800210a:	b112      	cbz	r2, 8002112 <osEE_scheduler_task_not_terminated+0x22>
    p_ccb->d_isr_all_cnt = 0U;
 800210c:	2200      	movs	r2, #0
 800210e:	779a      	strb	r2, [r3, #30]
  OSEE_SEI();
 8002110:	b662      	cpsie	i
  OSEE_GET_IPL(flags);
 8002112:	f3ef 8311 	mrs	r3, BASEPRI
  flags >>= OSEE_CORTEX_M_PRIO_SH_BITS;
 8002116:	091b      	lsrs	r3, r3, #4
  if ( (flags == 0x00U) || (flags > OSEE_ISR2_MAX_HW_PRIO) ) {
 8002118:	3b01      	subs	r3, #1
 800211a:	2b07      	cmp	r3, #7
 800211c:	d902      	bls.n	8002124 <osEE_scheduler_task_not_terminated+0x34>
    OSEE_SET_IPL(OSEE_ISR2_MAX_HW_PRIO << OSEE_CORTEX_M_PRIO_SH_BITS);
 800211e:	2380      	movs	r3, #128	; 0x80
 8002120:	f383 8811 	msr	BASEPRI, r3
 8002124:	4902      	ldr	r1, [pc, #8]	; (8002130 <osEE_scheduler_task_not_terminated+0x40>)
 8002126:	6840      	ldr	r0, [r0, #4]
 8002128:	f7fe fa8a 	bl	8000640 <osEE_hal_terminate_ctx>
 800212c:	08002510 	.word	0x08002510
 8002130:	08002335 	.word	0x08002335

08002134 <osEE_scheduler_task_wrapper_restore>:
  }

#endif /* OSEE_HAS_ORTI */

  /* Set the TASK status to RUNNING. Before calling PreTaskHook */
  p_tdb_to->p_tcb->status = OSEE_TASK_RUNNING;
 8002134:	6883      	ldr	r3, [r0, #8]
 8002136:	2204      	movs	r2, #4
 8002138:	709a      	strb	r2, [r3, #2]
    }
  }
#endif /* OSEE_SCHEDULER_GLOBAL */

  return;
}
 800213a:	4770      	bx	lr

0800213c <osEE_scheduler_task_wrapper_run>:
FUNC(void, OS_CODE)
  osEE_scheduler_task_wrapper_run
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_to
)
{
 800213c:	b538      	push	{r3, r4, r5, lr}
 800213e:	4605      	mov	r5, r0
  CONST(TaskPrio, AUTOMATIC) task_priority = p_tdb_to->p_tcb->current_prio;
 8002140:	6883      	ldr	r3, [r0, #8]
 8002142:	785c      	ldrb	r4, [r3, #1]
  osEE_scheduler_task_wrapper_restore(p_tdb_to);
 8002144:	f7ff fff6 	bl	8002134 <osEE_scheduler_task_wrapper_restore>

  if (task_priority < OSEE_ISR_ALL_PRIO) {
 8002148:	2cff      	cmp	r4, #255	; 0xff
 800214a:	d006      	beq.n	800215a <osEE_scheduler_task_wrapper_run+0x1e>
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
 800214c:	f014 0f80 	tst.w	r4, #128	; 0x80
 8002150:	d108      	bne.n	8002164 <osEE_scheduler_task_wrapper_run+0x28>
    OSEE_SET_IPL(OSEE_ISR_UNMASKED << OSEE_CORTEX_M_PRIO_SH_BITS);
 8002152:	2300      	movs	r3, #0
 8002154:	f383 8811 	msr	BASEPRI, r3
  OSEE_SEI();
 8002158:	b662      	cpsie	i
    /* Set-up IPL at current TASK level in addition to enable IRQ */
    osEE_hal_set_ipl(task_priority);
    osEE_hal_enableIRQ();
  }
  p_tdb_to->task_func();
 800215a:	696b      	ldr	r3, [r5, #20]
 800215c:	4798      	blx	r3

  /* Unexpected TASK Function return */
  osEE_scheduler_task_not_terminated(p_tdb_to);
 800215e:	4628      	mov	r0, r5
 8002160:	f7ff ffc6 	bl	80020f0 <osEE_scheduler_task_not_terminated>
    OSEE_SET_IPL(
 8002164:	f1c4 040f 	rsb	r4, r4, #15
 8002168:	0124      	lsls	r4, r4, #4
 800216a:	b2e4      	uxtb	r4, r4
 800216c:	f384 8811 	msr	BASEPRI, r4
 8002170:	e7f2      	b.n	8002158 <osEE_scheduler_task_wrapper_run+0x1c>
	...

08002174 <osEE_idle_hook_wrapper>:
FUNC(void, OS_CODE)
  osEE_idle_hook_wrapper
(
  void
)
{
 8002174:	b508      	push	{r3, lr}
  /* Schedule Here: Autostart TASKs */
  CONST(OsEE_reg, AUTOMATIC) flags = osEE_begin_primitive();
  (void)osEE_scheduler_task_preemption_point(osEE_get_kernel());
  osEE_end_primitive(flags);
#endif /* !OSEE_STARTOS_RETURN && !OSEE_API_DYNAMIC && !OSEE_HAS_AUTOSTART_TASK */
  while (p_cdb->p_ccb->os_status == OSEE_KERNEL_STARTED) {
 8002176:	4b08      	ldr	r3, [pc, #32]	; (8002198 <osEE_idle_hook_wrapper+0x24>)
 8002178:	681b      	ldr	r3, [r3, #0]
 800217a:	7c1b      	ldrb	r3, [r3, #16]
 800217c:	b2db      	uxtb	r3, r3
 800217e:	2b02      	cmp	r3, #2
 8002180:	d105      	bne.n	800218e <osEE_idle_hook_wrapper+0x1a>
#if (defined(OSEE_HAS_IDLEHOOK)) || (defined(OSEE_API_DYNAMIC))
    CONST(TaskFunc, AUTOMATIC) p_idle_hook = p_cdb->p_idle_hook;
 8002182:	4b05      	ldr	r3, [pc, #20]	; (8002198 <osEE_idle_hook_wrapper+0x24>)
 8002184:	685b      	ldr	r3, [r3, #4]
    if (p_idle_hook != NULL) {
 8002186:	2b00      	cmp	r3, #0
 8002188:	d0f5      	beq.n	8002176 <osEE_idle_hook_wrapper+0x2>
      p_idle_hook();
 800218a:	4798      	blx	r3
 800218c:	e7f3      	b.n	8002176 <osEE_idle_hook_wrapper+0x2>
    }
#else
    ; /* Empty Endless Loop */
#endif /* OSEE_HAS_IDLEHOOK || OSEE_API_DYNAMIC */
  }
  osEE_idle_task_terminate(p_cdb->p_idle_task);
 800218e:	4b02      	ldr	r3, [pc, #8]	; (8002198 <osEE_idle_hook_wrapper+0x24>)
 8002190:	6898      	ldr	r0, [r3, #8]
 8002192:	f000 f8b9 	bl	8002308 <osEE_idle_task_terminate>
}
 8002196:	bd08      	pop	{r3, pc}
 8002198:	08002510 	.word	0x08002510

0800219c <osEE_task_activated>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
  VAR(StatusType, AUTOMATIC)                    ev;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act = p_tdb_act->p_tcb;
 800219c:	6882      	ldr	r2, [r0, #8]
#else
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  if (p_tcb_act->current_num_of_act < p_tdb_act->max_num_of_act) {
 800219e:	7813      	ldrb	r3, [r2, #0]
 80021a0:	7e81      	ldrb	r1, [r0, #26]
 80021a2:	428b      	cmp	r3, r1
 80021a4:	d203      	bcs.n	80021ae <osEE_task_activated+0x12>
    ++p_tcb_act->current_num_of_act;
 80021a6:	3301      	adds	r3, #1
 80021a8:	7013      	strb	r3, [r2, #0]
    ev = E_OK;
 80021aa:	2000      	movs	r0, #0
 80021ac:	4770      	bx	lr
  } else {
    ev = E_OS_LIMIT;
 80021ae:	2004      	movs	r0, #4
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  return ev;
}
 80021b0:	4770      	bx	lr

080021b2 <osEE_task_end>:
(
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb
)
{
  /* It has to be called already in Multi-Core critical section */
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
 80021b2:	6882      	ldr	r2, [r0, #8]

  p_tcb->current_prio = p_tdb->ready_prio;
 80021b4:	7e03      	ldrb	r3, [r0, #24]
 80021b6:	7053      	strb	r3, [r2, #1]

  --p_tcb->current_num_of_act;
 80021b8:	7813      	ldrb	r3, [r2, #0]
 80021ba:	3b01      	subs	r3, #1
 80021bc:	b2db      	uxtb	r3, r3
 80021be:	7013      	strb	r3, [r2, #0]

  if (p_tcb->current_num_of_act == 0U) {
 80021c0:	b113      	cbz	r3, 80021c8 <osEE_task_end+0x16>
    p_tcb->status = OSEE_TASK_SUSPENDED;
  } else {
    p_tcb->status = OSEE_TASK_READY;
 80021c2:	2301      	movs	r3, #1
 80021c4:	7093      	strb	r3, [r2, #2]
  }
}
 80021c6:	4770      	bx	lr
    p_tcb->status = OSEE_TASK_SUSPENDED;
 80021c8:	7093      	strb	r3, [r2, #2]
 80021ca:	4770      	bx	lr

080021cc <osEE_scheduler_task_insert_rq>:
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act,
  P2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)  p_tcb_act
)
{
 80021cc:	b508      	push	{r3, lr}
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;

  /* Actually Insert the activated in Ready Queue.
   * Change Status only if is not active yet. */
  if (p_tcb_act->status == OSEE_TASK_SUSPENDED) {
 80021ce:	7893      	ldrb	r3, [r2, #2]
 80021d0:	b90b      	cbnz	r3, 80021d6 <osEE_scheduler_task_insert_rq+0xa>
    p_tcb_act->status = OSEE_TASK_READY;
 80021d2:	2301      	movs	r3, #1
 80021d4:	7093      	strb	r3, [r2, #2]
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
 80021d6:	6883      	ldr	r3, [r0, #8]
  (*pp_first)              = p_sn_allocated->p_next;
 80021d8:	681a      	ldr	r2, [r3, #0]
 80021da:	6082      	str	r2, [r0, #8]
  p_sn_allocated->p_next  = NULL;
 80021dc:	2200      	movs	r2, #0
 80021de:	601a      	str	r2, [r3, #0]
    osEE_task_event_reset_mask(p_tcb_act);
  }

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
 80021e0:	460a      	mov	r2, r1
 80021e2:	4619      	mov	r1, r3
 80021e4:	3004      	adds	r0, #4
 80021e6:	f000 f927 	bl	8002438 <osEE_scheduler_rq_insert>
    osEE_sn_alloc(&p_ccb->p_free_sn), p_tdb_act);

  return rq_head_changed;
}
 80021ea:	bd08      	pop	{r3, pc}

080021ec <osEE_scheduler_task_activated>:
  osEE_scheduler_task_activated
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
 80021ec:	b570      	push	{r4, r5, r6, lr}
  VAR(OsEE_bool, AUTOMATIC)   is_preemption;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act   = p_tdb_act->p_tcb;
 80021ee:	688a      	ldr	r2, [r1, #8]
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_act);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb       = p_cdb->p_ccb;
 80021f0:	4b0e      	ldr	r3, [pc, #56]	; (800222c <osEE_scheduler_task_activated+0x40>)
 80021f2:	6818      	ldr	r0, [r3, #0]
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_curr      = p_ccb->p_curr;
 80021f4:	6804      	ldr	r4, [r0, #0]
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_curr_tcb  = p_curr->p_tcb;
 80021f6:	68a5      	ldr	r5, [r4, #8]
    }
    is_preemption = OSEE_FALSE;
  } else
#endif /* !OSEE_SINGLECORE */
  /* Preemption Check */
  if (p_curr_tcb->current_prio < p_tcb_act->current_prio) {
 80021f8:	786e      	ldrb	r6, [r5, #1]
 80021fa:	7853      	ldrb	r3, [r2, #1]
 80021fc:	429e      	cmp	r6, r3
 80021fe:	d303      	bcc.n	8002208 <osEE_scheduler_task_activated+0x1c>
    osEE_change_context_from_running(p_curr, p_tdb_act);

    is_preemption = OSEE_TRUE;
  } else {
    /* Actually Insert the activated in READY Queue */
    (void)osEE_scheduler_task_insert_rq(p_ccb, p_tdb_act, p_tcb_act);
 8002200:	f7ff ffe4 	bl	80021cc <osEE_scheduler_task_insert_rq>

    osEE_unlock_core(p_cdb);

    is_preemption = OSEE_FALSE;
 8002204:	2000      	movs	r0, #0
  }

  return is_preemption;
}
 8002206:	bd70      	pop	{r4, r5, r6, pc}
  p_sn_allocated          = (*pp_first);
 8002208:	6883      	ldr	r3, [r0, #8]
  (*pp_first)              = p_sn_allocated->p_next;
 800220a:	681a      	ldr	r2, [r3, #0]
 800220c:	6082      	str	r2, [r0, #8]
  p_sn_allocated->p_next  = NULL;
 800220e:	2200      	movs	r2, #0
 8002210:	601a      	str	r2, [r3, #0]
    p_curr_tcb->status = OSEE_TASK_READY_STACKED;
 8002212:	2202      	movs	r2, #2
 8002214:	70aa      	strb	r2, [r5, #2]
    p_new_stk->p_tdb            = p_tdb_act;
 8002216:	6059      	str	r1, [r3, #4]
    p_new_stk->p_next           = p_ccb->p_stk_sn;
 8002218:	68c2      	ldr	r2, [r0, #12]
 800221a:	601a      	str	r2, [r3, #0]
    p_ccb->p_stk_sn             = p_new_stk;
 800221c:	60c3      	str	r3, [r0, #12]
    p_ccb->p_curr               = p_tdb_act;
 800221e:	6001      	str	r1, [r0, #0]
    osEE_change_context_from_running(p_curr, p_tdb_act);
 8002220:	4620      	mov	r0, r4
 8002222:	f000 f851 	bl	80022c8 <osEE_change_context_from_running>
    is_preemption = OSEE_TRUE;
 8002226:	2001      	movs	r0, #1
 8002228:	e7ed      	b.n	8002206 <osEE_scheduler_task_activated+0x1a>
 800222a:	bf00      	nop
 800222c:	08002510 	.word	0x08002510

08002230 <osEE_scheduler_task_terminated>:
  osEE_scheduler_task_terminated
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)    p_kdb,
  P2VAR(OsEE_TDB *, AUTOMATIC, OS_APPL_DATA)  pp_tdb_from
)
{
 8002230:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
 8002234:	4b1b      	ldr	r3, [pc, #108]	; (80022a4 <osEE_scheduler_task_terminated+0x74>)
 8002236:	681c      	ldr	r4, [r3, #0]
  /* Touch unused parameters */
  (void)p_kdb;
  osEE_lock_core(p_cdb);
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_term  = p_ccb->p_curr;
 8002238:	6825      	ldr	r5, [r4, #0]
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_tcb_term  = p_tdb_term->p_tcb;
 800223a:	68ae      	ldr	r6, [r5, #8]

    /* Prepare the TDB from return value */
    (*pp_tdb_from) = p_tdb_term;
 800223c:	600d      	str	r5, [r1, #0]
    /* We are having a termination so the hook flag has to be
       unset */
    p_ccb->p_last_tdb_hook = NULL;
#endif /* OSEE_HAS_PRETASKHOOK */

    if (p_tcb_term->status == OSEE_TASK_RUNNING) {
 800223e:	78b3      	ldrb	r3, [r6, #2]
 8002240:	2b04      	cmp	r3, #4
 8002242:	d015      	beq.n	8002270 <osEE_scheduler_task_terminated+0x40>
      /* In Normal Termination => SN released */
      osEE_sn_release(&p_ccb->p_free_sn, p_sn_term);
    } else {
      /* Handle ChainTask */
      CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn_term = p_ccb->p_stk_sn;
 8002244:	68e1      	ldr	r1, [r4, #12]

      /* Pop the current STK SN, if not IDLE TASK. This function MUST not be
       * called inside IDLE TASK. */
      p_ccb->p_stk_sn = p_sn_term->p_next;
 8002246:	680b      	ldr	r3, [r1, #0]
 8002248:	60e3      	str	r3, [r4, #12]
#endif /* OSEE_HAS_POSTTASKHOOK */

      /* I need to release internal resource for Chained TASK
       * (set ready prio instead of dispatch prio) to let RQ Tasks 'preempt'
       * the Chained. */
      p_tcb_term->current_prio = p_tdb_term->ready_prio;
 800224a:	7e2b      	ldrb	r3, [r5, #24]
 800224c:	7073      	strb	r3, [r6, #1]
      p_tcb_term->status = OSEE_TASK_READY;
 800224e:	2301      	movs	r3, #1
 8002250:	70b3      	strb	r3, [r6, #2]
      if (p_tcb_term->current_num_of_act == 1U) {
        osEE_task_event_reset_mask(p_tcb_term);
      }
#endif /* OSEE_HAS_EVENTS */

      (void)osEE_scheduler_rq_insert(&p_ccb->rq, p_sn_term, p_tdb_term);
 8002252:	1d23      	adds	r3, r4, #4
 8002254:	462a      	mov	r2, r5
 8002256:	461d      	mov	r5, r3
 8002258:	4618      	mov	r0, r3
 800225a:	f000 f8ed 	bl	8002438 <osEE_scheduler_rq_insert>

      {
        CONSTP2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)
          p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);
 800225e:	4629      	mov	r1, r5
 8002260:	4810      	ldr	r0, [pc, #64]	; (80022a4 <osEE_scheduler_task_terminated+0x74>)
 8002262:	f000 f8a5 	bl	80023b0 <osEE_scheduler_core_rq_preempt_stk>

        if (p_prev == NULL) {
 8002266:	b1c0      	cbz	r0, 800229a <osEE_scheduler_task_terminated+0x6a>
           * Not Needed to Check Idle TASK since just reinserted the chained
           * in RQ */
          p_tdb_to                = p_ccb->p_stk_sn->p_tdb;
          p_ccb->p_curr           = p_tdb_to;
        } else {
          p_tdb_to = p_ccb->p_curr;
 8002268:	6827      	ldr	r7, [r4, #0]
    }
  }
  osEE_unlock_core(p_cdb);

  return p_tdb_to;
}
 800226a:	4638      	mov	r0, r7
 800226c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        p_sn_term = osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);
 8002270:	1d21      	adds	r1, r4, #4
 8002272:	480c      	ldr	r0, [pc, #48]	; (80022a4 <osEE_scheduler_task_terminated+0x74>)
 8002274:	f000 f8e6 	bl	8002444 <osEE_scheduler_core_pop_running>
 8002278:	4680      	mov	r8, r0
      p_tdb_to = p_ccb->p_curr;
 800227a:	6827      	ldr	r7, [r4, #0]
      if (p_tdb_term != p_tdb_to) {
 800227c:	42bd      	cmp	r5, r7
 800227e:	d008      	beq.n	8002292 <osEE_scheduler_task_terminated+0x62>
        osEE_task_end(p_tdb_term);
 8002280:	4628      	mov	r0, r5
 8002282:	f7ff ff96 	bl	80021b2 <osEE_task_end>
(
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first,
  P2VAR(OsEE_SN  , AUTOMATIC, OS_APPL_DATA) p_to_free
)
{
  p_to_free->p_next = (*pp_first);
 8002286:	68a3      	ldr	r3, [r4, #8]
 8002288:	f8c8 3000 	str.w	r3, [r8]
  (*pp_first)       = p_to_free;
 800228c:	f8c4 8008 	str.w	r8, [r4, #8]
 8002290:	e7eb      	b.n	800226a <osEE_scheduler_task_terminated+0x3a>
        --p_tcb_term->current_num_of_act;
 8002292:	7833      	ldrb	r3, [r6, #0]
 8002294:	3b01      	subs	r3, #1
 8002296:	7033      	strb	r3, [r6, #0]
 8002298:	e7f5      	b.n	8002286 <osEE_scheduler_task_terminated+0x56>
          p_tdb_to                = p_ccb->p_stk_sn->p_tdb;
 800229a:	68e3      	ldr	r3, [r4, #12]
 800229c:	685f      	ldr	r7, [r3, #4]
          p_ccb->p_curr           = p_tdb_to;
 800229e:	6027      	str	r7, [r4, #0]
 80022a0:	e7e3      	b.n	800226a <osEE_scheduler_task_terminated+0x3a>
 80022a2:	bf00      	nop
 80022a4:	08002510 	.word	0x08002510

080022a8 <osEE_scheduler_task_preemption_point>:
FUNC(OsEE_bool, OS_CODE)
  osEE_scheduler_task_preemption_point
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb
)
{
 80022a8:	b510      	push	{r4, lr}
  VAR(OsEE_bool, AUTOMATIC)                     is_preemption;
  P2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)  p_prev;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
 80022aa:	4806      	ldr	r0, [pc, #24]	; (80022c4 <osEE_scheduler_task_preemption_point+0x1c>)
 80022ac:	6804      	ldr	r4, [r0, #0]
  /* Touch unused parameters */
  (void)p_kdb;
  /* Lock the Scheduler */
  osEE_lock_core(p_cdb);

  p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);
 80022ae:	1d21      	adds	r1, r4, #4
 80022b0:	f000 f87e 	bl	80023b0 <osEE_scheduler_core_rq_preempt_stk>

  /* Unlock the Scheduler (critical section terminated) */
  osEE_unlock_core(p_cdb);

  if (p_prev != NULL) {
 80022b4:	b120      	cbz	r0, 80022c0 <osEE_scheduler_task_preemption_point+0x18>
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_curr = p_ccb->p_curr;

    osEE_change_context_from_running(p_prev, p_curr);
 80022b6:	6821      	ldr	r1, [r4, #0]
 80022b8:	f000 f806 	bl	80022c8 <osEE_change_context_from_running>

    is_preemption = OSEE_TRUE;
 80022bc:	2001      	movs	r0, #1
  } else {
    is_preemption = OSEE_FALSE;
  }

  return is_preemption;
}
 80022be:	bd10      	pop	{r4, pc}
    is_preemption = OSEE_FALSE;
 80022c0:	2000      	movs	r0, #0
 80022c2:	e7fc      	b.n	80022be <osEE_scheduler_task_preemption_point+0x16>
 80022c4:	08002510 	.word	0x08002510

080022c8 <osEE_change_context_from_running>:
  osEE_change_context_from_running
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_from,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
 80022c8:	b508      	push	{r3, lr}
 80022ca:	460b      	mov	r3, r1
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;
 80022cc:	688a      	ldr	r2, [r1, #8]

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
 80022ce:	7892      	ldrb	r2, [r2, #2]
 80022d0:	2a02      	cmp	r2, #2
 80022d2:	d005      	beq.n	80022e0 <osEE_change_context_from_running+0x18>
    osEE_hal_save_ctx_and_restore_ctx(p_to, p_to->hdb.p_scb,
      p_from->hdb.p_scb);
  } else {
    osEE_hal_save_ctx_and_ready2stacked(p_to, p_to->hdb.p_scb,
 80022d4:	6842      	ldr	r2, [r0, #4]
 80022d6:	6849      	ldr	r1, [r1, #4]
 80022d8:	4618      	mov	r0, r3
 80022da:	f7fe f9a3 	bl	8000624 <osEE_hal_save_ctx_and_ready2stacked>
      p_from->hdb.p_scb);
  }
}
 80022de:	bd08      	pop	{r3, pc}
    osEE_hal_save_ctx_and_restore_ctx(p_to, p_to->hdb.p_scb,
 80022e0:	6842      	ldr	r2, [r0, #4]
 80022e2:	6849      	ldr	r1, [r1, #4]
 80022e4:	4618      	mov	r0, r3
 80022e6:	f7fe f979 	bl	80005dc <osEE_hal_save_ctx_and_restore_ctx>
 80022ea:	e7f8      	b.n	80022de <osEE_change_context_from_running+0x16>

080022ec <osEE_change_context_from_task_end>:
  osEE_change_context_from_task_end
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_from,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
 80022ec:	b508      	push	{r3, lr}
 80022ee:	4608      	mov	r0, r1
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;
 80022f0:	688b      	ldr	r3, [r1, #8]

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
 80022f2:	789b      	ldrb	r3, [r3, #2]
 80022f4:	2b02      	cmp	r3, #2
 80022f6:	d003      	beq.n	8002300 <osEE_change_context_from_task_end+0x14>
    osEE_hal_restore_ctx(p_to, p_to->hdb.p_scb);
  } else {
    osEE_hal_ready2stacked(p_to, p_to->hdb.p_scb);
 80022f8:	6849      	ldr	r1, [r1, #4]
 80022fa:	f7fe f98d 	bl	8000618 <osEE_hal_ready2stacked>
  }
  /* STD Implementation do not use p_from here, but I cannot assure
     that any implementation won't do that */
  (void)p_from;
}
 80022fe:	bd08      	pop	{r3, pc}
    osEE_hal_restore_ctx(p_to, p_to->hdb.p_scb);
 8002300:	6849      	ldr	r1, [r1, #4]
 8002302:	f7fe f979 	bl	80005f8 <osEE_hal_restore_ctx>
 8002306:	e7fa      	b.n	80022fe <osEE_change_context_from_task_end+0x12>

08002308 <osEE_idle_task_terminate>:
FUNC(void, OS_CODE)
  osEE_idle_task_terminate
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_idle_tdb
)
{
 8002308:	b510      	push	{r4, lr}
  P2VAR(OsEE_CTX, AUTOMATIC, OS_APPL_DATA)      p_ctx;

  CONSTP2VAR(OsEE_HDB, AUTOMATIC, OS_APPL_DATA) p_idle_hdb  = &p_idle_tdb->hdb;
  CONSTP2VAR(OsEE_SDB, AUTOMATIC, OS_APPL_DATA) p_sdb       = p_idle_hdb->p_sdb;
 800230a:	6803      	ldr	r3, [r0, #0]
  CONSTP2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA) p_scb       = p_idle_hdb->p_scb;
 800230c:	6841      	ldr	r1, [r0, #4]
  CONSTP2CONST(OsEE_CTX, AUTOMATIC, OS_APPL_DATA) p_bos     = p_sdb->p_bos;
 800230e:	681c      	ldr	r4, [r3, #0]
  P2VAR(OsEE_CTX, AUTOMATIC, OS_APPL_DATA)      p_tos       = p_scb->p_tos;
 8002310:	680a      	ldr	r2, [r1, #0]
 8002312:	e000      	b.n	8002316 <osEE_idle_task_terminate+0xe>

  do {
    p_ctx = p_tos;
    p_tos = p_tos->p_ctx;
 8002314:	461a      	mov	r2, r3
 8002316:	6813      	ldr	r3, [r2, #0]
  } while ((p_tos != NULL) && (p_tos != p_bos));
 8002318:	b10b      	cbz	r3, 800231e <osEE_idle_task_terminate+0x16>
 800231a:	429c      	cmp	r4, r3
 800231c:	d1fa      	bne.n	8002314 <osEE_idle_task_terminate+0xc>

  /* Unwind the stack until the last context*/
  p_scb->p_tos = p_ctx;
 800231e:	600a      	str	r2, [r1, #0]

  osEE_hal_restore_ctx(p_idle_tdb, p_scb);
 8002320:	f7fe f96a 	bl	80005f8 <osEE_hal_restore_ctx>
}
 8002324:	bd10      	pop	{r4, pc}

08002326 <osEE_cortex_m_system_init>:

/*
 * System Initialization.
 */
FUNC(void, OS_CODE) osEE_cortex_m_system_init(void)
{
 8002326:	b508      	push	{r3, lr}
	/* 
	 * Set the priority of PendSV to the minimum one
	 * PendSV is the software interrupt used for context switch
	 */
	osEE_set_switch_context_pri();
 8002328:	f7fe f99e 	bl	8000668 <osEE_set_switch_context_pri>
#endif	/* OSEE_CORTEX_M_SYSTICK_ISR */

	/* 
	 * MCU System Initialization.
	 */
	osEE_cortex_m_mcu_system_init();
 800232c:	f000 f89c 	bl	8002468 <osEE_cortex_m_mcu_system_init>

}	/* osEE_cortex_m_system_init() */
 8002330:	bd08      	pop	{r3, pc}
	...

08002334 <osEE_cortex_m_scheduler_task_end>:
 *  \date   2016
 */
#include "ee_internal.h"

FUNC(void, OS_CODE) osEE_cortex_m_scheduler_task_end(void)
{
 8002334:	b570      	push	{r4, r5, r6, lr}
 8002336:	b082      	sub	sp, #8

  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb = p_cdb->p_ccb;
 8002338:	4b14      	ldr	r3, [pc, #80]	; (800238c <osEE_cortex_m_scheduler_task_end+0x58>)
 800233a:	681c      	ldr	r4, [r3, #0]
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)   p_term_sn = p_ccb->p_stk_sn;
 800233c:	68e5      	ldr	r5, [r4, #12]
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_orig_task_sn = p_term_sn->p_next;
 800233e:	682b      	ldr	r3, [r5, #0]
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_orig_tdb;

  /* p_orig_task_sn == NULL means I preempted idle task */
  if (p_orig_task_sn != NULL) {
 8002340:	b173      	cbz	r3, 8002360 <osEE_cortex_m_scheduler_task_end+0x2c>
    p_orig_tdb = p_orig_task_sn->p_tdb;
 8002342:	685e      	ldr	r6, [r3, #4]
    /* Set PendSV */
    osEE_cortex_m_trigger_pend_sv();
    osEE_hal_restore_ctx(p_orig_tdb, p_orig_tdb->hdb.p_scb);
  }
#else
  if (p_ccb->p_curr->task_type != OSEE_TASK_TYPE_ISR2) {
 8002344:	6822      	ldr	r2, [r4, #0]
 8002346:	7c12      	ldrb	r2, [r2, #16]
 8002348:	2a02      	cmp	r2, #2
 800234a:	d00c      	beq.n	8002366 <osEE_cortex_m_scheduler_task_end+0x32>
    P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)            p_from;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)       p_to =
 800234c:	a901      	add	r1, sp, #4
 800234e:	4810      	ldr	r0, [pc, #64]	; (8002390 <osEE_cortex_m_scheduler_task_end+0x5c>)
 8002350:	f7ff ff6e 	bl	8002230 <osEE_scheduler_task_terminated>
      osEE_scheduler_task_terminated(osEE_get_kernel(), &p_from);

    osEE_change_context_from_task_end(p_from, p_to);
 8002354:	4601      	mov	r1, r0
 8002356:	9801      	ldr	r0, [sp, #4]
 8002358:	f7ff ffc8 	bl	80022ec <osEE_change_context_from_task_end>
       (osEE_cortex_m_isr2_stub) after osEE_activate_isr2(t) call */
    osEE_hal_restore_ctx(p_orig_tdb, p_orig_tdb->hdb.p_scb);
  }
#endif

}
 800235c:	b002      	add	sp, #8
 800235e:	bd70      	pop	{r4, r5, r6, pc}
    p_orig_tdb = p_cdb->p_idle_task;
 8002360:	4a0a      	ldr	r2, [pc, #40]	; (800238c <osEE_cortex_m_scheduler_task_end+0x58>)
 8002362:	6896      	ldr	r6, [r2, #8]
 8002364:	e7ee      	b.n	8002344 <osEE_cortex_m_scheduler_task_end+0x10>
    p_ccb->p_stk_sn = p_orig_task_sn;
 8002366:	60e3      	str	r3, [r4, #12]
    osEE_task_end(p_term_sn->p_tdb);
 8002368:	6868      	ldr	r0, [r5, #4]
 800236a:	f7ff ff22 	bl	80021b2 <osEE_task_end>
    p_ccb->p_curr = p_orig_tdb;
 800236e:	6026      	str	r6, [r4, #0]
    p_orig_tdb->p_tcb->status = OSEE_TASK_RUNNING;
 8002370:	68b3      	ldr	r3, [r6, #8]
 8002372:	2204      	movs	r2, #4
 8002374:	709a      	strb	r2, [r3, #2]
  p_to_free->p_next = (*pp_first);
 8002376:	68a3      	ldr	r3, [r4, #8]
 8002378:	602b      	str	r3, [r5, #0]
  (*pp_first)       = p_to_free;
 800237a:	60a5      	str	r5, [r4, #8]
    osEE_cortex_m_trigger_pend_sv();
 800237c:	f7fe f982 	bl	8000684 <osEE_cortex_m_trigger_pend_sv>
    osEE_hal_restore_ctx(p_orig_tdb, p_orig_tdb->hdb.p_scb);
 8002380:	6871      	ldr	r1, [r6, #4]
 8002382:	4630      	mov	r0, r6
 8002384:	f7fe f938 	bl	80005f8 <osEE_hal_restore_ctx>
}
 8002388:	e7e8      	b.n	800235c <osEE_cortex_m_scheduler_task_end+0x28>
 800238a:	bf00      	nop
 800238c:	08002510 	.word	0x08002510
 8002390:	0800251c 	.word	0x0800251c

08002394 <osEE_scheduler_stk_next>:
  osEE_scheduler_stk_next
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn
)
{
 8002394:	b410      	push	{r4}
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb = p_rq_sn->p_tdb;
 8002396:	684b      	ldr	r3, [r1, #4]
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
 8002398:	689a      	ldr	r2, [r3, #8]
  /* N.B. The Handling of the preempted SN as Stacked or re-inserted in RQ
   * is done by the calling function */
  p_rq_sn->p_next               = NULL;
  p_tcb->current_core_id        = osEE_get_curr_core_id();
#else
  p_rq_sn->p_next               = p_ccb->p_stk_sn;
 800239a:	68c4      	ldr	r4, [r0, #12]
 800239c:	600c      	str	r4, [r1, #0]
#endif /* OSEE_ALLOW_TASK_MIGRATION */
  p_ccb->p_stk_sn               = p_rq_sn;
 800239e:	60c1      	str	r1, [r0, #12]
  p_ccb->p_curr                 = p_tdb;
 80023a0:	6003      	str	r3, [r0, #0]

  /* Adjust actual priority with dispatch priority: if needed */
  {
    CONST(TaskPrio, AUTOMATIC)
      dispatch_prio = p_tdb->dispatch_prio;
 80023a2:	7e5b      	ldrb	r3, [r3, #25]
    if (p_tcb->current_prio < dispatch_prio) {
 80023a4:	7851      	ldrb	r1, [r2, #1]
 80023a6:	4299      	cmp	r1, r3
 80023a8:	d200      	bcs.n	80023ac <osEE_scheduler_stk_next+0x18>
      p_tcb->current_prio = dispatch_prio;
 80023aa:	7053      	strb	r3, [r2, #1]
    }
  }
}
 80023ac:	bc10      	pop	{r4}
 80023ae:	4770      	bx	lr

080023b0 <osEE_scheduler_core_rq_preempt_stk>:
  osEE_scheduler_core_rq_preempt_stk
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
 80023b0:	b570      	push	{r4, r5, r6, lr}
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
 80023b2:	6802      	ldr	r2, [r0, #0]
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn  = (*p_rq);
 80023b4:	680b      	ldr	r3, [r1, #0]
  P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)     p_ret_sn = p_ccb->p_stk_sn;
 80023b6:	68d4      	ldr	r4, [r2, #12]

  VAR(OsEE_bool, AUTOMATIC)                     is_rq_preemption = OSEE_FALSE;
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)      p_ret_tdb;

  if (p_ret_sn != NULL) {
 80023b8:	b194      	cbz	r4, 80023e0 <osEE_scheduler_core_rq_preempt_stk+0x30>
    p_ret_tdb = p_ret_sn->p_tdb;
 80023ba:	6864      	ldr	r4, [r4, #4]
    if (p_rq_sn != NULL) {
 80023bc:	b1b3      	cbz	r3, 80023ec <osEE_scheduler_core_rq_preempt_stk+0x3c>
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
 80023be:	68a0      	ldr	r0, [r4, #8]
      if (p_ret_tcb->current_prio <
 80023c0:	7846      	ldrb	r6, [r0, #1]
        p_rq_sn->p_tdb->p_tcb->current_prio)
 80023c2:	685d      	ldr	r5, [r3, #4]
 80023c4:	68ad      	ldr	r5, [r5, #8]
 80023c6:	786d      	ldrb	r5, [r5, #1]
      if (p_ret_tcb->current_prio <
 80023c8:	42ae      	cmp	r6, r5
 80023ca:	d211      	bcs.n	80023f0 <osEE_scheduler_core_rq_preempt_stk+0x40>
      {
        /* RQ preempt STK */
        /* Call PostTaskHook before switching active TASK */
        osEE_call_post_task_hook(p_ccb);

        p_ret_tcb->status = OSEE_TASK_READY_STACKED;
 80023cc:	2502      	movs	r5, #2
 80023ce:	7085      	strb	r5, [r0, #2]
    p_ret_tdb = NULL;
  }

  if (is_rq_preemption) {
    /* Extract from ready queue */
    (*p_rq)       = p_rq_sn->p_next;
 80023d0:	6818      	ldr	r0, [r3, #0]
 80023d2:	6008      	str	r0, [r1, #0]

    /* Set as current on top of STK */
    osEE_scheduler_stk_next(p_ccb, p_rq_sn);
 80023d4:	4619      	mov	r1, r3
 80023d6:	4610      	mov	r0, r2
 80023d8:	f7ff ffdc 	bl	8002394 <osEE_scheduler_stk_next>
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  return p_ret_sn;
#else
  return p_ret_tdb;
#endif /* OSEE_ALLOW_TASK_MIGRATION */
}
 80023dc:	4620      	mov	r0, r4
 80023de:	bd70      	pop	{r4, r5, r6, pc}
  } else if (p_rq_sn != NULL) {
 80023e0:	b143      	cbz	r3, 80023f4 <osEE_scheduler_core_rq_preempt_stk+0x44>
    p_ret_tdb                 = p_cdb->p_idle_task;
 80023e2:	6884      	ldr	r4, [r0, #8]
    p_ret_tdb->p_tcb->status  = OSEE_TASK_READY_STACKED;
 80023e4:	68a0      	ldr	r0, [r4, #8]
 80023e6:	2502      	movs	r5, #2
 80023e8:	7085      	strb	r5, [r0, #2]
 80023ea:	e7f1      	b.n	80023d0 <osEE_scheduler_core_rq_preempt_stk+0x20>
    p_ret_tdb = NULL;
 80023ec:	2400      	movs	r4, #0
 80023ee:	e7f5      	b.n	80023dc <osEE_scheduler_core_rq_preempt_stk+0x2c>
 80023f0:	2400      	movs	r4, #0
 80023f2:	e7f3      	b.n	80023dc <osEE_scheduler_core_rq_preempt_stk+0x2c>
 80023f4:	2400      	movs	r4, #0
  return p_ret_tdb;
 80023f6:	e7f1      	b.n	80023dc <osEE_scheduler_core_rq_preempt_stk+0x2c>

080023f8 <osEE_sn_priority_insert>:
(
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA)     pp_first,
  P2VAR(OsEE_SN  , AUTOMATIC, OS_APPL_DATA)     p_sn_new,
  CONST(OsEE_bool, AUTOMATIC)                   as_ready
)
{
 80023f8:	b4f0      	push	{r4, r5, r6, r7}
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_tdb_new = p_sn_new->p_tdb;
 80023fa:	684b      	ldr	r3, [r1, #4]
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_new = p_tdb_new->p_tcb;
 80023fc:	689c      	ldr	r4, [r3, #8]
  CONST(TaskPrio, AUTOMATIC)                  new_task_prio =
 80023fe:	4617      	mov	r7, r2
 8002400:	b11a      	cbz	r2, 800240a <osEE_sn_priority_insert+0x12>
 8002402:	7e1e      	ldrb	r6, [r3, #24]
    (as_ready)?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
 8002404:	6803      	ldr	r3, [r0, #0]
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
 8002406:	2500      	movs	r5, #0
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
 8002408:	e006      	b.n	8002418 <osEE_sn_priority_insert+0x20>
  CONST(TaskPrio, AUTOMATIC)                  new_task_prio =
 800240a:	7866      	ldrb	r6, [r4, #1]
 800240c:	e7fa      	b.n	8002404 <osEE_sn_priority_insert+0xc>
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_cur_tcb = p_cur_tdb->p_tcb;

    if (as_ready) {
      prio_to_check = p_cur_tdb->ready_prio;
    } else {
      prio_to_check = p_cur_tcb->current_prio;
 800240e:	7862      	ldrb	r2, [r4, #1]
    }

    if (new_task_prio <= prio_to_check)
 8002410:	42b2      	cmp	r2, r6
 8002412:	d308      	bcc.n	8002426 <osEE_sn_priority_insert+0x2e>
    {
      p_prev = p_curr;
 8002414:	461d      	mov	r5, r3
      p_curr = p_curr->p_next;
 8002416:	681b      	ldr	r3, [r3, #0]
  while (p_curr != NULL) {
 8002418:	b12b      	cbz	r3, 8002426 <osEE_sn_priority_insert+0x2e>
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_cur_tdb = p_curr->p_tdb;
 800241a:	685a      	ldr	r2, [r3, #4]
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_cur_tcb = p_cur_tdb->p_tcb;
 800241c:	6894      	ldr	r4, [r2, #8]
    if (as_ready) {
 800241e:	2f00      	cmp	r7, #0
 8002420:	d0f5      	beq.n	800240e <osEE_sn_priority_insert+0x16>
      prio_to_check = p_cur_tdb->ready_prio;
 8002422:	7e12      	ldrb	r2, [r2, #24]
 8002424:	e7f4      	b.n	8002410 <osEE_sn_priority_insert+0x18>
    } else {
      break;
    }
  }

  if (p_prev != NULL) {
 8002426:	b125      	cbz	r5, 8002432 <osEE_sn_priority_insert+0x3a>
    p_prev->p_next = p_sn_new;
 8002428:	6029      	str	r1, [r5, #0]
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;
 800242a:	2000      	movs	r0, #0
  } else {
    (*pp_first)   = p_sn_new;
    head_changed  = OSEE_TRUE;
  }

  p_sn_new->p_next = p_curr;
 800242c:	600b      	str	r3, [r1, #0]

  return head_changed;
}
 800242e:	bcf0      	pop	{r4, r5, r6, r7}
 8002430:	4770      	bx	lr
    (*pp_first)   = p_sn_new;
 8002432:	6001      	str	r1, [r0, #0]
    head_changed  = OSEE_TRUE;
 8002434:	2001      	movs	r0, #1
 8002436:	e7f9      	b.n	800242c <osEE_sn_priority_insert+0x34>

08002438 <osEE_scheduler_rq_insert>:
{
 8002438:	b508      	push	{r3, lr}
  p_sn_new->p_tdb = p_tdb_new;
 800243a:	604a      	str	r2, [r1, #4]
  return osEE_sn_priority_insert(p_rq, p_sn_new, OSEE_TRUE);
 800243c:	2201      	movs	r2, #1
 800243e:	f7ff ffdb 	bl	80023f8 <osEE_sn_priority_insert>
}
 8002442:	bd08      	pop	{r3, pc}

08002444 <osEE_scheduler_core_pop_running>:
  osEE_scheduler_core_pop_running
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
 8002444:	b570      	push	{r4, r5, r6, lr}
 8002446:	4606      	mov	r6, r0
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb         = p_cdb->p_ccb;
 8002448:	6804      	ldr	r4, [r0, #0]
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_prev_stk_sn = p_ccb->p_stk_sn;
 800244a:	68e5      	ldr	r5, [r4, #12]
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_next_stk_sn = p_prev_stk_sn->p_next;
 800244c:	682b      	ldr	r3, [r5, #0]

  /* Pop the current STK SN, if not IDLE TASK. This function MUST not be
   * called inside IDLE TASK. */
  p_ccb->p_stk_sn = p_next_stk_sn;
 800244e:	60e3      	str	r3, [r4, #12]
   * */

  {
    /* Handle if RQ preempt STK (It manipulate the core data structures) */
    CONSTP2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)
      p_preempt = osEE_scheduler_core_rq_preempt_stk(p_cdb, p_rq);
 8002450:	f7ff ffae 	bl	80023b0 <osEE_scheduler_core_rq_preempt_stk>
    CONSTP2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
      p_curr_stk_sn = p_ccb->p_stk_sn;
 8002454:	68e3      	ldr	r3, [r4, #12]

    /* If not, resume current STK first */
    if (p_preempt == NULL) {
 8002456:	b108      	cbz	r0, 800245c <osEE_scheduler_core_pop_running+0x18>
    }
#endif /* OSEE_ALLOW_TASK_MIGRATION */
  }

  return p_prev_stk_sn;
}
 8002458:	4628      	mov	r0, r5
 800245a:	bd70      	pop	{r4, r5, r6, pc}
      if (p_curr_stk_sn != NULL) {
 800245c:	b113      	cbz	r3, 8002464 <osEE_scheduler_core_pop_running+0x20>
        p_tdb_stk = p_curr_stk_sn->p_tdb;
 800245e:	685b      	ldr	r3, [r3, #4]
      p_ccb->p_curr            = p_tdb_stk;
 8002460:	6023      	str	r3, [r4, #0]
  return p_prev_stk_sn;
 8002462:	e7f9      	b.n	8002458 <osEE_scheduler_core_pop_running+0x14>
        p_tdb_stk = p_cdb->p_idle_task;
 8002464:	68b3      	ldr	r3, [r6, #8]
 8002466:	e7fb      	b.n	8002460 <osEE_scheduler_core_pop_running+0x1c>

08002468 <osEE_cortex_m_mcu_system_init>:
)
#define	OSEE_CORTEX_M_USART2_NUM		(			\
	OSEE_CORTEX_M_USART2_ISR_ID - OSEE_CORTEX_M_OVERALL_EXC_NUM	\
)
#ifdef	OSEE_CORTEX_M_USART2_ISR_PRI
	OSEE_CORTEX_M_NVIC_SET_PRI(
 8002468:	4b07      	ldr	r3, [pc, #28]	; (8002488 <osEE_cortex_m_mcu_system_init+0x20>)
 800246a:	681a      	ldr	r2, [r3, #0]
 800246c:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
 8002470:	601a      	str	r2, [r3, #0]
 8002472:	681a      	ldr	r2, [r3, #0]
 8002474:	f442 02e0 	orr.w	r2, r2, #7340032	; 0x700000
 8002478:	601a      	str	r2, [r3, #0]
		OSEE_CORTEX_M_USART2_NUM, OSEE_CORTEX_M_USART2_ISR_PRI
	);
#endif	/* OSEE_CORTEX_M_USART2_ISR_PRI */
	OSEE_CORTEX_M_NVIC_INT_ENABLE(OSEE_CORTEX_M_USART2_NUM);
 800247a:	4a04      	ldr	r2, [pc, #16]	; (800248c <osEE_cortex_m_mcu_system_init+0x24>)
 800247c:	6813      	ldr	r3, [r2, #0]
 800247e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8002482:	6013      	str	r3, [r2, #0]
	);
#endif	/* OSEE_CORTEX_M_DMA2D_ISR_PRI */
	OSEE_CORTEX_M_NVIC_INT_ENABLE(OSEE_CORTEX_M_DMA2D_NUM);
#endif	/* OSEE_CORTEX_M_DMA2D_ISR */
#endif	/* OS_EE_ARCH_CORTEX_M_STM32F429xx */
}	/* osEE_cortex_m_mcu_system_init() */
 8002484:	4770      	bx	lr
 8002486:	bf00      	nop
 8002488:	e000e424 	.word	0xe000e424
 800248c:	e000e104 	.word	0xe000e104

08002490 <USART2_IRQHandler>:
 * USART2 global interrupt
 */
#if (defined(OSEE_CORTEX_M_USART2_ISR_TID)) && (OSEE_CORTEX_M_USART2_ISR_CAT == 2)
OSEE_CORTEX_M_ISR2_DEFINITION(USART2_IRQHandler, OSEE_CORTEX_M_USART2_ISR_TID)
#elif (defined(OSEE_CORTEX_M_USART2_ISR)) && (OSEE_CORTEX_M_USART2_ISR_CAT == 1)
OSEE_CORTEX_M_ISR1_DEFINITION(USART2_IRQHandler, OSEE_CORTEX_M_USART2_ISR)
 8002490:	b508      	push	{r3, lr}
 8002492:	4802      	ldr	r0, [pc, #8]	; (800249c <USART2_IRQHandler+0xc>)
 8002494:	f000 f81a 	bl	80024cc <osEE_cortex_m_isr1_stub>
 8002498:	bd08      	pop	{r3, pc}
 800249a:	bf00      	nop
 800249c:	08000971 	.word	0x08000971

080024a0 <osEE_cortex_m_change_context_from_task_end>:
#include "ee_internal.h"

FUNC(void, OS_CODE) osEE_cortex_m_change_context_from_task_end(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_orig_tdb
)
{
 80024a0:	b510      	push	{r4, lr}
  OSEE_GET_IPL(flags);
 80024a2:	f3ef 8411 	mrs	r4, BASEPRI
  flags >>= OSEE_CORTEX_M_PRIO_SH_BITS;
 80024a6:	0923      	lsrs	r3, r4, #4
  if ( (flags == 0x00U) || (flags > OSEE_ISR2_MAX_HW_PRIO) ) {
 80024a8:	3b01      	subs	r3, #1
 80024aa:	2b07      	cmp	r3, #7
 80024ac:	d902      	bls.n	80024b4 <osEE_cortex_m_change_context_from_task_end+0x14>
    OSEE_SET_IPL(OSEE_ISR2_MAX_HW_PRIO << OSEE_CORTEX_M_PRIO_SH_BITS);
 80024ae:	2380      	movs	r3, #128	; 0x80
 80024b0:	f383 8811 	msr	BASEPRI, r3
  OSEE_SEI();
 80024b4:	b662      	cpsie	i
  OsEE_reg f = osEE_hal_begin_nested_primitive();

  osEE_hal_enableIRQ();

  (void)osEE_scheduler_task_preemption_point(osEE_get_kernel());
 80024b6:	4804      	ldr	r0, [pc, #16]	; (80024c8 <osEE_cortex_m_change_context_from_task_end+0x28>)
 80024b8:	f7ff fef6 	bl	80022a8 <osEE_scheduler_task_preemption_point>
  OSEE_CLI();
 80024bc:	b672      	cpsid	i
  OSEE_SET_IPL(flag << OSEE_CORTEX_M_PRIO_SH_BITS);
 80024be:	f024 040f 	bic.w	r4, r4, #15
 80024c2:	f384 8811 	msr	BASEPRI, r4

  osEE_hal_disableIRQ();

  osEE_hal_end_nested_primitive(f);
}
 80024c6:	bd10      	pop	{r4, pc}
 80024c8:	0800251c 	.word	0x0800251c

080024cc <osEE_cortex_m_isr1_stub>:
 */
FUNC(void, OS_CODE) OSEE_COMPILER_KEEP
osEE_cortex_m_isr1_stub(
  VAR(OsEE_void_cb, AUTOMATIC)	f
)
{
 80024cc:	b508      	push	{r3, lr}

  /* Call The ISR User Handler */
  f();
 80024ce:	4780      	blx	r0

}	/* osEE_cortex_m_isr1_stub() */
 80024d0:	bd08      	pop	{r3, pc}
	...

080024d4 <_init>:
 80024d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80024d6:	bf00      	nop
 80024d8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80024da:	bc08      	pop	{r3}
 80024dc:	469e      	mov	lr, r3
 80024de:	4770      	bx	lr

080024e0 <_fini>:
 80024e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80024e2:	bf00      	nop
 80024e4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80024e6:	bc08      	pop	{r3}
 80024e8:	469e      	mov	lr, r3
 80024ea:	4770      	bx	lr
